// Code generated by protoc-gen-twirp v8.1.3, DO NOT EDIT.
// source: api/build/bazel/remote/execution/v2/remote_execution.proto

package remoteexecution

import context "context"
import fmt "fmt"
import http "net/http"
import io "io"
import json "encoding/json"
import strconv "strconv"
import strings "strings"

import protojson "google.golang.org/protobuf/encoding/protojson"
import proto "google.golang.org/protobuf/proto"
import twirp "github.com/twitchtv/twirp"
import ctxsetters "github.com/twitchtv/twirp/ctxsetters"

import google_longrunning "cloud.google.com/go/longrunning/autogen/longrunningpb"

import bytes "bytes"
import errors "errors"
import path "path"
import url "net/url"

// Version compatibility assertion.
// If the constant is not defined in the package, that likely means
// the package needs to be updated to work with this generated code.
// See https://twitchtv.github.io/twirp/docs/version_matrix.html
const _ = twirp.TwirpPackageMinVersion_8_1_0

// ===================
// Execution Interface
// ===================

// The Remote Execution API is used to execute an
// [Action][build.bazel.remote.execution.v2.Action] on the remote
// workers.
//
// As with other services in the Remote Execution API, any call may return an
// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
// information about when the client should retry the request; clients SHOULD
// respect the information provided.
type Execution interface {
	// Execute an action remotely.
	//
	// In order to execute an action, the client must first upload all of the
	// inputs, the
	// [Command][build.bazel.remote.execution.v2.Command] to run, and the
	// [Action][build.bazel.remote.execution.v2.Action] into the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage].
	// It then calls `Execute` with an `action_digest` referring to them. The
	// server will run the action and eventually return the result.
	//
	// The input `Action`'s fields MUST meet the various canonicalization
	// requirements specified in the documentation for their types so that it has
	// the same digest as other logically equivalent `Action`s. The server MAY
	// enforce the requirements and return errors if a non-canonical input is
	// received. It MAY also proceed without verifying some or all of the
	// requirements, such as for performance reasons. If the server does not
	// verify the requirement, then it will treat the `Action` as distinct from
	// another logically equivalent action if they hash differently.
	//
	// Returns a stream of
	// [google.longrunning.Operation][google.longrunning.Operation] messages
	// describing the resulting execution, with eventual `response`
	// [ExecuteResponse][build.bazel.remote.execution.v2.ExecuteResponse]. The
	// `metadata` on the operation is of type
	// [ExecuteOperationMetadata][build.bazel.remote.execution.v2.ExecuteOperationMetadata].
	//
	// If the client remains connected after the first response is returned after
	// the server, then updates are streamed as if the client had called
	// [WaitExecution][build.bazel.remote.execution.v2.Execution.WaitExecution]
	// until the execution completes or the request reaches an error. The
	// operation can also be queried using [Operations
	// API][google.longrunning.Operations.GetOperation].
	//
	// The server NEED NOT implement other methods or functionality of the
	// Operations API.
	//
	// Errors discovered during creation of the `Operation` will be reported
	// as gRPC Status errors, while errors that occurred while running the
	// action will be reported in the `status` field of the `ExecuteResponse`. The
	// server MUST NOT set the `error` field of the `Operation` proto.
	// The possible errors include:
	//
	// * `INVALID_ARGUMENT`: One or more arguments are invalid.
	// * `FAILED_PRECONDITION`: One or more errors occurred in setting up the
	//   action requested, such as a missing input or command or no worker being
	//   available. The client may be able to fix the errors and retry.
	// * `RESOURCE_EXHAUSTED`: There is insufficient quota of some resource to run
	//   the action.
	// * `UNAVAILABLE`: Due to a transient condition, such as all workers being
	//   occupied (and the server does not support a queue), the action could not
	//   be started. The client should retry.
	// * `INTERNAL`: An internal error occurred in the execution engine or the
	//   worker.
	// * `DEADLINE_EXCEEDED`: The execution timed out.
	// * `CANCELLED`: The operation was cancelled by the client. This status is
	//   only possible if the server implements the Operations API CancelOperation
	//   method, and it was called for the current execution.
	//
	// In the case of a missing input or command, the server SHOULD additionally
	// send a [PreconditionFailure][google.rpc.PreconditionFailure] error detail
	// where, for each requested blob not present in the CAS, there is a
	// `Violation` with a `type` of `MISSING` and a `subject` of
	// `"blobs/{digest_function/}{hash}/{size}"` indicating the digest of the
	// missing blob. The `subject` is formatted the same way as the
	// `resource_name` provided to
	// [ByteStream.Read][google.bytestream.ByteStream.Read], with the leading
	// instance name omitted. `digest_function` MUST thus be omitted if its value
	// is one of MD5, MURMUR3, SHA1, SHA256, SHA384, SHA512, or VSO.
	//
	// The server does not need to guarantee that a call to this method leads to
	// at most one execution of the action. The server MAY execute the action
	// multiple times, potentially in parallel. These redundant executions MAY
	// continue to run, even if the operation is completed.
	Execute(context.Context, *ExecuteRequest) (*google_longrunning.Operation, error)

	// Wait for an execution operation to complete. When the client initially
	// makes the request, the server immediately responds with the current status
	// of the execution. The server will leave the request stream open until the
	// operation completes, and then respond with the completed operation. The
	// server MAY choose to stream additional updates as execution progresses,
	// such as to provide an update as to the state of the execution.
	//
	// In addition to the cases describe for Execute, the WaitExecution method
	// may fail as follows:
	//
	// * `NOT_FOUND`: The operation no longer exists due to any of a transient
	//   condition, an unknown operation name, or if the server implements the
	//   Operations API DeleteOperation method and it was called for the current
	//   execution. The client should call `Execute` to retry.
	WaitExecution(context.Context, *WaitExecutionRequest) (*google_longrunning.Operation, error)
}

// =========================
// Execution Protobuf Client
// =========================

type executionProtobufClient struct {
	client      HTTPClient
	urls        [2]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewExecutionProtobufClient creates a Protobuf client that implements the Execution interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewExecutionProtobufClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) Execution {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "build.bazel.remote.execution.v2", "Execution")
	urls := [2]string{
		serviceURL + "Execute",
		serviceURL + "WaitExecution",
	}

	return &executionProtobufClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *executionProtobufClient) Execute(ctx context.Context, in *ExecuteRequest) (*google_longrunning.Operation, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "Execution")
	ctx = ctxsetters.WithMethodName(ctx, "Execute")
	caller := c.callExecute
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *ExecuteRequest) (*google_longrunning.Operation, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*ExecuteRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*ExecuteRequest) when calling interceptor")
					}
					return c.callExecute(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*google_longrunning.Operation)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*google_longrunning.Operation) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *executionProtobufClient) callExecute(ctx context.Context, in *ExecuteRequest) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *executionProtobufClient) WaitExecution(ctx context.Context, in *WaitExecutionRequest) (*google_longrunning.Operation, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "Execution")
	ctx = ctxsetters.WithMethodName(ctx, "WaitExecution")
	caller := c.callWaitExecution
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *WaitExecutionRequest) (*google_longrunning.Operation, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*WaitExecutionRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*WaitExecutionRequest) when calling interceptor")
					}
					return c.callWaitExecution(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*google_longrunning.Operation)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*google_longrunning.Operation) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *executionProtobufClient) callWaitExecution(ctx context.Context, in *WaitExecutionRequest) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// =====================
// Execution JSON Client
// =====================

type executionJSONClient struct {
	client      HTTPClient
	urls        [2]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewExecutionJSONClient creates a JSON client that implements the Execution interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewExecutionJSONClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) Execution {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "build.bazel.remote.execution.v2", "Execution")
	urls := [2]string{
		serviceURL + "Execute",
		serviceURL + "WaitExecution",
	}

	return &executionJSONClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *executionJSONClient) Execute(ctx context.Context, in *ExecuteRequest) (*google_longrunning.Operation, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "Execution")
	ctx = ctxsetters.WithMethodName(ctx, "Execute")
	caller := c.callExecute
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *ExecuteRequest) (*google_longrunning.Operation, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*ExecuteRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*ExecuteRequest) when calling interceptor")
					}
					return c.callExecute(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*google_longrunning.Operation)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*google_longrunning.Operation) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *executionJSONClient) callExecute(ctx context.Context, in *ExecuteRequest) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *executionJSONClient) WaitExecution(ctx context.Context, in *WaitExecutionRequest) (*google_longrunning.Operation, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "Execution")
	ctx = ctxsetters.WithMethodName(ctx, "WaitExecution")
	caller := c.callWaitExecution
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *WaitExecutionRequest) (*google_longrunning.Operation, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*WaitExecutionRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*WaitExecutionRequest) when calling interceptor")
					}
					return c.callWaitExecution(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*google_longrunning.Operation)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*google_longrunning.Operation) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *executionJSONClient) callWaitExecution(ctx context.Context, in *WaitExecutionRequest) (*google_longrunning.Operation, error) {
	out := new(google_longrunning.Operation)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ========================
// Execution Server Handler
// ========================

type executionServer struct {
	Execution
	interceptor      twirp.Interceptor
	hooks            *twirp.ServerHooks
	pathPrefix       string // prefix for routing
	jsonSkipDefaults bool   // do not include unpopulated fields (default values) in the response
	jsonCamelCase    bool   // JSON fields are serialized as lowerCamelCase rather than keeping the original proto names
}

// NewExecutionServer builds a TwirpServer that can be used as an http.Handler to handle
// HTTP requests that are routed to the right method in the provided svc implementation.
// The opts are twirp.ServerOption modifiers, for example twirp.WithServerHooks(hooks).
func NewExecutionServer(svc Execution, opts ...interface{}) TwirpServer {
	serverOpts := newServerOpts(opts)

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	jsonSkipDefaults := false
	_ = serverOpts.ReadOpt("jsonSkipDefaults", &jsonSkipDefaults)
	jsonCamelCase := false
	_ = serverOpts.ReadOpt("jsonCamelCase", &jsonCamelCase)
	var pathPrefix string
	if ok := serverOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	return &executionServer{
		Execution:        svc,
		hooks:            serverOpts.Hooks,
		interceptor:      twirp.ChainInterceptors(serverOpts.Interceptors...),
		pathPrefix:       pathPrefix,
		jsonSkipDefaults: jsonSkipDefaults,
		jsonCamelCase:    jsonCamelCase,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *executionServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	writeError(ctx, resp, err, s.hooks)
}

// handleRequestBodyError is used to handle error when the twirp server cannot read request
func (s *executionServer) handleRequestBodyError(ctx context.Context, resp http.ResponseWriter, msg string, err error) {
	if context.Canceled == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.Canceled, "failed to read request: context canceled"))
		return
	}
	if context.DeadlineExceeded == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.DeadlineExceeded, "failed to read request: deadline exceeded"))
		return
	}
	s.writeError(ctx, resp, twirp.WrapError(malformedRequestError(msg), err))
}

// ExecutionPathPrefix is a convenience constant that may identify URL paths.
// Should be used with caution, it only matches routes generated by Twirp Go clients,
// with the default "/twirp" prefix and default CamelCase service and method names.
// More info: https://twitchtv.github.io/twirp/docs/routing.html
const ExecutionPathPrefix = "/twirp/build.bazel.remote.execution.v2.Execution/"

func (s *executionServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "Execution")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = callRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	// Verify path format: [<prefix>]/<package>.<Service>/<Method>
	prefix, pkgService, method := parseTwirpPath(req.URL.Path)
	if pkgService != "build.bazel.remote.execution.v2.Execution" {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
	if prefix != s.pathPrefix {
		msg := fmt.Sprintf("invalid path prefix %q, expected %q, on path %q", prefix, s.pathPrefix, req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	switch method {
	case "Execute":
		s.serveExecute(ctx, resp, req)
		return
	case "WaitExecution":
		s.serveWaitExecution(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
}

func (s *executionServer) serveExecute(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveExecuteJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveExecuteProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *executionServer) serveExecuteJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "Execute")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(ExecuteRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.Execution.Execute
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *ExecuteRequest) (*google_longrunning.Operation, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*ExecuteRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*ExecuteRequest) when calling interceptor")
					}
					return s.Execution.Execute(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*google_longrunning.Operation)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*google_longrunning.Operation) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *google_longrunning.Operation
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *google_longrunning.Operation and nil error while calling Execute. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *executionServer) serveExecuteProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "Execute")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(ExecuteRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.Execution.Execute
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *ExecuteRequest) (*google_longrunning.Operation, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*ExecuteRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*ExecuteRequest) when calling interceptor")
					}
					return s.Execution.Execute(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*google_longrunning.Operation)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*google_longrunning.Operation) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *google_longrunning.Operation
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *google_longrunning.Operation and nil error while calling Execute. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *executionServer) serveWaitExecution(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveWaitExecutionJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveWaitExecutionProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *executionServer) serveWaitExecutionJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "WaitExecution")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(WaitExecutionRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.Execution.WaitExecution
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *WaitExecutionRequest) (*google_longrunning.Operation, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*WaitExecutionRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*WaitExecutionRequest) when calling interceptor")
					}
					return s.Execution.WaitExecution(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*google_longrunning.Operation)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*google_longrunning.Operation) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *google_longrunning.Operation
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *google_longrunning.Operation and nil error while calling WaitExecution. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *executionServer) serveWaitExecutionProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "WaitExecution")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(WaitExecutionRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.Execution.WaitExecution
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *WaitExecutionRequest) (*google_longrunning.Operation, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*WaitExecutionRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*WaitExecutionRequest) when calling interceptor")
					}
					return s.Execution.WaitExecution(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*google_longrunning.Operation)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*google_longrunning.Operation) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *google_longrunning.Operation
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *google_longrunning.Operation and nil error while calling WaitExecution. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *executionServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor0, 0
}

func (s *executionServer) ProtocGenTwirpVersion() string {
	return "v8.1.3"
}

// PathPrefix returns the base service path, in the form: "/<prefix>/<package>.<Service>/"
// that is everything in a Twirp route except for the <Method>. This can be used for routing,
// for example to identify the requests that are targeted to this service in a mux.
func (s *executionServer) PathPrefix() string {
	return baseServicePath(s.pathPrefix, "build.bazel.remote.execution.v2", "Execution")
}

// =====================
// ActionCache Interface
// =====================

// The action cache API is used to query whether a given action has already been
// performed and, if so, retrieve its result. Unlike the
// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage],
// which addresses blobs by their own content, the action cache addresses the
// [ActionResult][build.bazel.remote.execution.v2.ActionResult] by a
// digest of the encoded [Action][build.bazel.remote.execution.v2.Action]
// which produced them.
//
// The lifetime of entries in the action cache is implementation-specific, but
// the server SHOULD assume that more recently used entries are more likely to
// be used again.
//
// As with other services in the Remote Execution API, any call may return an
// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
// information about when the client should retry the request; clients SHOULD
// respect the information provided.
type ActionCache interface {
	// Retrieve a cached execution result.
	//
	// Implementations SHOULD ensure that any blobs referenced from the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
	// are available at the time of returning the
	// [ActionResult][build.bazel.remote.execution.v2.ActionResult] and will be
	// for some period of time afterwards. The lifetimes of the referenced blobs SHOULD be increased
	// if necessary and applicable.
	//
	// Errors:
	//
	// * `NOT_FOUND`: The requested `ActionResult` is not in the cache.
	GetActionResult(context.Context, *GetActionResultRequest) (*ActionResult, error)

	// Upload a new execution result.
	//
	// In order to allow the server to perform access control based on the type of
	// action, and to assist with client debugging, the client MUST first upload
	// the [Action][build.bazel.remote.execution.v2.Action] that produced the
	// result, along with its
	// [Command][build.bazel.remote.execution.v2.Command], into the
	// `ContentAddressableStorage`.
	//
	// Server implementations MAY modify the
	// `UpdateActionResultRequest.action_result` and return an equivalent value.
	//
	// Errors:
	//
	// * `INVALID_ARGUMENT`: One or more arguments are invalid.
	// * `FAILED_PRECONDITION`: One or more errors occurred in updating the
	//   action result, such as a missing command or action.
	// * `RESOURCE_EXHAUSTED`: There is insufficient storage space to add the
	//   entry to the cache.
	UpdateActionResult(context.Context, *UpdateActionResultRequest) (*ActionResult, error)
}

// ===========================
// ActionCache Protobuf Client
// ===========================

type actionCacheProtobufClient struct {
	client      HTTPClient
	urls        [2]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewActionCacheProtobufClient creates a Protobuf client that implements the ActionCache interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewActionCacheProtobufClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) ActionCache {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "build.bazel.remote.execution.v2", "ActionCache")
	urls := [2]string{
		serviceURL + "GetActionResult",
		serviceURL + "UpdateActionResult",
	}

	return &actionCacheProtobufClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *actionCacheProtobufClient) GetActionResult(ctx context.Context, in *GetActionResultRequest) (*ActionResult, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ActionCache")
	ctx = ctxsetters.WithMethodName(ctx, "GetActionResult")
	caller := c.callGetActionResult
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *GetActionResultRequest) (*ActionResult, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetActionResultRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetActionResultRequest) when calling interceptor")
					}
					return c.callGetActionResult(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ActionResult)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ActionResult) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *actionCacheProtobufClient) callGetActionResult(ctx context.Context, in *GetActionResultRequest) (*ActionResult, error) {
	out := new(ActionResult)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *actionCacheProtobufClient) UpdateActionResult(ctx context.Context, in *UpdateActionResultRequest) (*ActionResult, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ActionCache")
	ctx = ctxsetters.WithMethodName(ctx, "UpdateActionResult")
	caller := c.callUpdateActionResult
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UpdateActionResultRequest) (*ActionResult, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UpdateActionResultRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UpdateActionResultRequest) when calling interceptor")
					}
					return c.callUpdateActionResult(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ActionResult)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ActionResult) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *actionCacheProtobufClient) callUpdateActionResult(ctx context.Context, in *UpdateActionResultRequest) (*ActionResult, error) {
	out := new(ActionResult)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// =======================
// ActionCache JSON Client
// =======================

type actionCacheJSONClient struct {
	client      HTTPClient
	urls        [2]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewActionCacheJSONClient creates a JSON client that implements the ActionCache interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewActionCacheJSONClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) ActionCache {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "build.bazel.remote.execution.v2", "ActionCache")
	urls := [2]string{
		serviceURL + "GetActionResult",
		serviceURL + "UpdateActionResult",
	}

	return &actionCacheJSONClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *actionCacheJSONClient) GetActionResult(ctx context.Context, in *GetActionResultRequest) (*ActionResult, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ActionCache")
	ctx = ctxsetters.WithMethodName(ctx, "GetActionResult")
	caller := c.callGetActionResult
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *GetActionResultRequest) (*ActionResult, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetActionResultRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetActionResultRequest) when calling interceptor")
					}
					return c.callGetActionResult(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ActionResult)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ActionResult) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *actionCacheJSONClient) callGetActionResult(ctx context.Context, in *GetActionResultRequest) (*ActionResult, error) {
	out := new(ActionResult)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *actionCacheJSONClient) UpdateActionResult(ctx context.Context, in *UpdateActionResultRequest) (*ActionResult, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ActionCache")
	ctx = ctxsetters.WithMethodName(ctx, "UpdateActionResult")
	caller := c.callUpdateActionResult
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UpdateActionResultRequest) (*ActionResult, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UpdateActionResultRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UpdateActionResultRequest) when calling interceptor")
					}
					return c.callUpdateActionResult(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ActionResult)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ActionResult) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *actionCacheJSONClient) callUpdateActionResult(ctx context.Context, in *UpdateActionResultRequest) (*ActionResult, error) {
	out := new(ActionResult)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ==========================
// ActionCache Server Handler
// ==========================

type actionCacheServer struct {
	ActionCache
	interceptor      twirp.Interceptor
	hooks            *twirp.ServerHooks
	pathPrefix       string // prefix for routing
	jsonSkipDefaults bool   // do not include unpopulated fields (default values) in the response
	jsonCamelCase    bool   // JSON fields are serialized as lowerCamelCase rather than keeping the original proto names
}

// NewActionCacheServer builds a TwirpServer that can be used as an http.Handler to handle
// HTTP requests that are routed to the right method in the provided svc implementation.
// The opts are twirp.ServerOption modifiers, for example twirp.WithServerHooks(hooks).
func NewActionCacheServer(svc ActionCache, opts ...interface{}) TwirpServer {
	serverOpts := newServerOpts(opts)

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	jsonSkipDefaults := false
	_ = serverOpts.ReadOpt("jsonSkipDefaults", &jsonSkipDefaults)
	jsonCamelCase := false
	_ = serverOpts.ReadOpt("jsonCamelCase", &jsonCamelCase)
	var pathPrefix string
	if ok := serverOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	return &actionCacheServer{
		ActionCache:      svc,
		hooks:            serverOpts.Hooks,
		interceptor:      twirp.ChainInterceptors(serverOpts.Interceptors...),
		pathPrefix:       pathPrefix,
		jsonSkipDefaults: jsonSkipDefaults,
		jsonCamelCase:    jsonCamelCase,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *actionCacheServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	writeError(ctx, resp, err, s.hooks)
}

// handleRequestBodyError is used to handle error when the twirp server cannot read request
func (s *actionCacheServer) handleRequestBodyError(ctx context.Context, resp http.ResponseWriter, msg string, err error) {
	if context.Canceled == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.Canceled, "failed to read request: context canceled"))
		return
	}
	if context.DeadlineExceeded == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.DeadlineExceeded, "failed to read request: deadline exceeded"))
		return
	}
	s.writeError(ctx, resp, twirp.WrapError(malformedRequestError(msg), err))
}

// ActionCachePathPrefix is a convenience constant that may identify URL paths.
// Should be used with caution, it only matches routes generated by Twirp Go clients,
// with the default "/twirp" prefix and default CamelCase service and method names.
// More info: https://twitchtv.github.io/twirp/docs/routing.html
const ActionCachePathPrefix = "/twirp/build.bazel.remote.execution.v2.ActionCache/"

func (s *actionCacheServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ActionCache")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = callRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	// Verify path format: [<prefix>]/<package>.<Service>/<Method>
	prefix, pkgService, method := parseTwirpPath(req.URL.Path)
	if pkgService != "build.bazel.remote.execution.v2.ActionCache" {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
	if prefix != s.pathPrefix {
		msg := fmt.Sprintf("invalid path prefix %q, expected %q, on path %q", prefix, s.pathPrefix, req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	switch method {
	case "GetActionResult":
		s.serveGetActionResult(ctx, resp, req)
		return
	case "UpdateActionResult":
		s.serveUpdateActionResult(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
}

func (s *actionCacheServer) serveGetActionResult(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveGetActionResultJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveGetActionResultProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *actionCacheServer) serveGetActionResultJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "GetActionResult")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(GetActionResultRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.ActionCache.GetActionResult
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *GetActionResultRequest) (*ActionResult, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetActionResultRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetActionResultRequest) when calling interceptor")
					}
					return s.ActionCache.GetActionResult(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ActionResult)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ActionResult) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *ActionResult
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ActionResult and nil error while calling GetActionResult. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *actionCacheServer) serveGetActionResultProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "GetActionResult")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(GetActionResultRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.ActionCache.GetActionResult
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *GetActionResultRequest) (*ActionResult, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetActionResultRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetActionResultRequest) when calling interceptor")
					}
					return s.ActionCache.GetActionResult(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ActionResult)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ActionResult) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *ActionResult
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ActionResult and nil error while calling GetActionResult. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *actionCacheServer) serveUpdateActionResult(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveUpdateActionResultJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveUpdateActionResultProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *actionCacheServer) serveUpdateActionResultJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "UpdateActionResult")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(UpdateActionResultRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.ActionCache.UpdateActionResult
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UpdateActionResultRequest) (*ActionResult, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UpdateActionResultRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UpdateActionResultRequest) when calling interceptor")
					}
					return s.ActionCache.UpdateActionResult(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ActionResult)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ActionResult) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *ActionResult
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ActionResult and nil error while calling UpdateActionResult. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *actionCacheServer) serveUpdateActionResultProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "UpdateActionResult")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(UpdateActionResultRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.ActionCache.UpdateActionResult
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UpdateActionResultRequest) (*ActionResult, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UpdateActionResultRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UpdateActionResultRequest) when calling interceptor")
					}
					return s.ActionCache.UpdateActionResult(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ActionResult)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ActionResult) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *ActionResult
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ActionResult and nil error while calling UpdateActionResult. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *actionCacheServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor0, 1
}

func (s *actionCacheServer) ProtocGenTwirpVersion() string {
	return "v8.1.3"
}

// PathPrefix returns the base service path, in the form: "/<prefix>/<package>.<Service>/"
// that is everything in a Twirp route except for the <Method>. This can be used for routing,
// for example to identify the requests that are targeted to this service in a mux.
func (s *actionCacheServer) PathPrefix() string {
	return baseServicePath(s.pathPrefix, "build.bazel.remote.execution.v2", "ActionCache")
}

// ===================================
// ContentAddressableStorage Interface
// ===================================

// The CAS (content-addressable storage) is used to store the inputs to and
// outputs from the execution service. Each piece of content is addressed by the
// digest of its binary data.
//
// Most of the binary data stored in the CAS is opaque to the execution engine,
// and is only used as a communication medium. In order to build an
// [Action][build.bazel.remote.execution.v2.Action],
// however, the client will need to also upload the
// [Command][build.bazel.remote.execution.v2.Command] and input root
// [Directory][build.bazel.remote.execution.v2.Directory] for the Action.
// The Command and Directory messages must be marshalled to wire format and then
// uploaded under the hash as with any other piece of content. In practice, the
// input root directory is likely to refer to other Directories in its
// hierarchy, which must also each be uploaded on their own.
//
// For small file uploads the client should group them together and call
// [BatchUpdateBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchUpdateBlobs].
//
// For large uploads, the client must use the
// [Write method][google.bytestream.ByteStream.Write] of the ByteStream API.
//
// For uncompressed data, The `WriteRequest.resource_name` is of the following form:
// `{instance_name}/uploads/{uuid}/blobs/{digest_function/}{hash}/{size}{/optional_metadata}`
//
// Where:
//   - `instance_name` is an identifier used to distinguish between the various
//     instances on the server. Syntax and semantics of this field are defined
//     by the server; Clients must not make any assumptions about it (e.g.,
//     whether it spans multiple path segments or not). If it is the empty path,
//     the leading slash is omitted, so that  the `resource_name` becomes
//     `uploads/{uuid}/blobs/{digest_function/}{hash}/{size}{/optional_metadata}`.
//     To simplify parsing, a path segment cannot equal any of the following
//     keywords: `blobs`, `uploads`, `actions`, `actionResults`, `operations`,
//     `capabilities` or `compressed-blobs`.
//   - `uuid` is a version 4 UUID generated by the client, used to avoid
//     collisions between concurrent uploads of the same data. Clients MAY
//     reuse the same `uuid` for uploading different blobs.
//   - `digest_function` is a lowercase string form of a `DigestFunction.Value`
//     enum, indicating which digest function was used to compute `hash`. If the
//     digest function used is one of MD5, MURMUR3, SHA1, SHA256, SHA384, SHA512,
//     or VSO, this component MUST be omitted. In that case the server SHOULD
//     infer the digest function using the length of the `hash` and the digest
//     functions announced in the server's capabilities.
//   - `hash` and `size` refer to the [Digest][build.bazel.remote.execution.v2.Digest]
//     of the data being uploaded.
//   - `optional_metadata` is implementation specific data, which clients MAY omit.
//     Servers MAY ignore this metadata.
//
// Data can alternatively be uploaded in compressed form, with the following
// `WriteRequest.resource_name` form:
// `{instance_name}/uploads/{uuid}/compressed-blobs/{compressor}/{digest_function/}{uncompressed_hash}/{uncompressed_size}{/optional_metadata}`
//
// Where:
//   - `instance_name`, `uuid`, `digest_function` and `optional_metadata` are
//     defined as above.
//   - `compressor` is a lowercase string form of a `Compressor.Value` enum
//     other than `identity`, which is supported by the server and advertised in
//     [CacheCapabilities.supported_compressor][build.bazel.remote.execution.v2.CacheCapabilities.supported_compressor].
//   - `uncompressed_hash` and `uncompressed_size` refer to the
//     [Digest][build.bazel.remote.execution.v2.Digest] of the data being
//     uploaded, once uncompressed. Servers MUST verify that these match
//     the uploaded data once uncompressed, and MUST return an
//     `INVALID_ARGUMENT` error in the case of mismatch.
//
// Note that when writing compressed blobs, the `WriteRequest.write_offset` in
// the initial request in a stream refers to the offset in the uncompressed form
// of the blob. In subsequent requests, `WriteRequest.write_offset` MUST be the
// sum of the first request's 'WriteRequest.write_offset' and the total size of
// all the compressed data bundles in the previous requests.
// Note that this mixes an uncompressed offset with a compressed byte length,
// which is nonsensical, but it is done to fit the semantics of the existing
// ByteStream protocol.
//
// Uploads of the same data MAY occur concurrently in any form, compressed or
// uncompressed.
//
// Clients SHOULD NOT use gRPC-level compression for ByteStream API `Write`
// calls of compressed blobs, since this would compress already-compressed data.
//
// When attempting an upload, if another client has already completed the upload
// (which may occur in the middle of a single upload if another client uploads
// the same blob concurrently), the request will terminate immediately without
// error, and with a response whose `committed_size` is the value `-1` if this
// is a compressed upload, or with the full size of the uploaded file if this is
// an uncompressed upload (regardless of how much data was transmitted by the
// client). If the client completes the upload but the
// [Digest][build.bazel.remote.execution.v2.Digest] does not match, an
// `INVALID_ARGUMENT` error will be returned. In either case, the client should
// not attempt to retry the upload.
//
// Small downloads can be grouped and requested in a batch via
// [BatchReadBlobs][build.bazel.remote.execution.v2.ContentAddressableStorage.BatchReadBlobs].
//
// For large downloads, the client must use the
// [Read method][google.bytestream.ByteStream.Read] of the ByteStream API.
//
// For uncompressed data, The `ReadRequest.resource_name` is of the following form:
// `{instance_name}/blobs/{digest_function/}{hash}/{size}`
// Where `instance_name`, `digest_function`, `hash` and `size` are defined as
// for uploads.
//
// Data can alternatively be downloaded in compressed form, with the following
// `ReadRequest.resource_name` form:
// `{instance_name}/compressed-blobs/{compressor}/{digest_function/}{uncompressed_hash}/{uncompressed_size}`
//
// Where:
//   - `instance_name`, `compressor` and `digest_function` are defined as for
//     uploads.
//   - `uncompressed_hash` and `uncompressed_size` refer to the
//     [Digest][build.bazel.remote.execution.v2.Digest] of the data being
//     downloaded, once uncompressed. Clients MUST verify that these match
//     the downloaded data once uncompressed, and take appropriate steps in
//     the case of failure such as retrying a limited number of times or
//     surfacing an error to the user.
//
// When downloading compressed blobs:
//   - `ReadRequest.read_offset` refers to the offset in the uncompressed form
//     of the blob.
//   - Servers MUST return `INVALID_ARGUMENT` if `ReadRequest.read_limit` is
//     non-zero.
//   - Servers MAY use any compression level they choose, including different
//     levels for different blobs (e.g. choosing a level designed for maximum
//     speed for data known to be incompressible).
//   - Clients SHOULD NOT use gRPC-level compression, since this would compress
//     already-compressed data.
//
// Servers MUST be able to provide data for all recently advertised blobs in
// each of the compression formats that the server supports, as well as in
// uncompressed form.
//
// Additionally, ByteStream requests MAY come with an additional plain text header
// that indicates the `resource_name` of the blob being sent.  The header, if
// present, MUST follow the following convention:
// * name: `build.bazel.remote.execution.v2.resource-name`.
// * contents: the plain text resource_name of the request message.
// If set, the contents of the header MUST match the `resource_name` of the request
// message.  Servers MAY use this header to assist in routing requests to the
// appropriate backend.
//
// The lifetime of entries in the CAS is implementation specific, but it SHOULD
// be long enough to allow for newly-added and recently looked-up entries to be
// used in subsequent calls (e.g. to
// [Execute][build.bazel.remote.execution.v2.Execution.Execute]).
//
// Servers MUST behave as though empty blobs are always available, even if they
// have not been uploaded. Clients MAY optimize away the uploading or
// downloading of empty blobs.
//
// As with other services in the Remote Execution API, any call may return an
// error with a [RetryInfo][google.rpc.RetryInfo] error detail providing
// information about when the client should retry the request; clients SHOULD
// respect the information provided.
type ContentAddressableStorage interface {
	// Determine if blobs are present in the CAS.
	//
	// Clients can use this API before uploading blobs to determine which ones are
	// already present in the CAS and do not need to be uploaded again.
	//
	// Servers SHOULD increase the lifetimes of the referenced blobs if necessary and
	// applicable.
	//
	// There are no method-specific errors.
	FindMissingBlobs(context.Context, *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error)

	// Upload many blobs at once.
	//
	// The server may enforce a limit of the combined total size of blobs
	// to be uploaded using this API. This limit may be obtained using the
	// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
	// Requests exceeding the limit should either be split into smaller
	// chunks or uploaded using the
	// [ByteStream API][google.bytestream.ByteStream], as appropriate.
	//
	// This request is equivalent to calling a Bytestream `Write` request
	// on each individual blob, in parallel. The requests may succeed or fail
	// independently.
	//
	// Errors:
	//
	// * `INVALID_ARGUMENT`: The client attempted to upload more than the
	//   server supported limit.
	//
	// Individual requests may return the following errors, additionally:
	//
	// * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob.
	// * `INVALID_ARGUMENT`: The
	// [Digest][build.bazel.remote.execution.v2.Digest] does not match the
	// provided data.
	BatchUpdateBlobs(context.Context, *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error)

	// Download many blobs at once.
	//
	// The server may enforce a limit of the combined total size of blobs
	// to be downloaded using this API. This limit may be obtained using the
	// [Capabilities][build.bazel.remote.execution.v2.Capabilities] API.
	// Requests exceeding the limit should either be split into smaller
	// chunks or downloaded using the
	// [ByteStream API][google.bytestream.ByteStream], as appropriate.
	//
	// This request is equivalent to calling a Bytestream `Read` request
	// on each individual blob, in parallel. The requests may succeed or fail
	// independently.
	//
	// Errors:
	//
	// * `INVALID_ARGUMENT`: The client attempted to read more than the
	//   server supported limit.
	//
	// Every error on individual read will be returned in the corresponding digest
	// status.
	BatchReadBlobs(context.Context, *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error)

	// Fetch the entire directory tree rooted at a node.
	//
	// This request must be targeted at a
	// [Directory][build.bazel.remote.execution.v2.Directory] stored in the
	// [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
	// (CAS). The server will enumerate the `Directory` tree recursively and
	// return every node descended from the root.
	//
	// The GetTreeRequest.page_token parameter can be used to skip ahead in
	// the stream (e.g. when retrying a partially completed and aborted request),
	// by setting it to a value taken from GetTreeResponse.next_page_token of the
	// last successfully processed GetTreeResponse).
	//
	// The exact traversal order is unspecified and, unless retrieving subsequent
	// pages from an earlier request, is not guaranteed to be stable across
	// multiple invocations of `GetTree`.
	//
	// If part of the tree is missing from the CAS, the server will return the
	// portion present and omit the rest.
	//
	// Errors:
	//
	// * `NOT_FOUND`: The requested tree root is not present in the CAS.
	GetTree(context.Context, *GetTreeRequest) (*GetTreeResponse, error)

	// SplitBlob retrieves information about how a blob is split into chunks.
	//
	// This call returns information about how a blob is split into chunks, and
	// returns a list of the chunk digests. Using the returned list of chunk digests,
	// a client can check which chunks are locally available and only fetch the
	// missing ones. The desired blob can be assembled by concatenating the fetched
	// chunks in the order of the digests in the list. The chunks SHOULD all be
	// available in the CAS.
	//
	// This API can be used to reduce the required data to download a large blob
	// from CAS if some chunks from similar blobs are locally available. For this
	// procedure to work properly, blobs SHOULD be split in a content-defined way,
	// rather than with fixed-sized chunking.
	//
	// If a split request is answered successfully, a client can expect the
	// following guarantees from the server:
	//  1. The blob chunks are stored in CAS.
	//  2. Concatenating the blob chunks in the order of the digest list returned
	//     by the server results in the original blob.
	//
	// Servers which implement this functionality MUST declare that they support
	// it by setting the
	// [CacheCapabilities.split_blob_support][build.bazel.remote.execution.v2.CacheCapabilities.split_blob_support]
	// field accordingly.
	//
	// Clients MUST check that the server supports this capability, before using
	// it.
	//
	// Clients SHOULD verify that the digest of the blob assembled by the fetched
	// chunks is equal to the requested blob digest.
	//
	// The lifetimes of the generated chunk blobs MAY be independent of the
	// lifetime of the original blob. In particular:
	//  * A blob and any chunk derived from it MAY be evicted from the CAS at
	//    different times.
	//  * A call to [SplitBlob][build.bazel.remote.execution.v2.ContentAddressableStorage.SplitBlob]
	//    extends the lifetime of the original blob, and sets the lifetimes of
	//    the resulting chunks (or extends the lifetimes of already-existing
	//    chunks).
	//  * Touching a chunk extends its lifetime, but the server MAY choose not
	//    to extend the lifetime of the original blob.
	//  * Touching the original blob extends its lifetime, but the server MAY
	//    choose not to extend the lifetimes of chunks derived from it.
	//
	// When blob splitting and splicing is used at the same time, the clients and
	// the server SHOULD agree out-of-band upon a chunking algorithm used by both
	// parties to benefit from each others chunk data and avoid unnecessary data
	// duplication.
	//
	// Errors:
	//
	// * `NOT_FOUND`: The requested blob is not present in the CAS, OR there is no
	//   split information available for the blob, OR at least one chunk needed to
	//   reconstruct the blob is missing from the CAS.
	// * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the blob
	//   chunks.
	SplitBlob(context.Context, *SplitBlobRequest) (*SplitBlobResponse, error)

	// SpliceBlob tells the CAS how chunks can compose a blob.
	//
	// This is the complementary operation to the
	// [ContentAddressableStorage.SplitBlob][build.bazel.remote.execution.v2.ContentAddressableStorage.SplitBlob]
	// function to handle the chunked upload of large blobs to save upload
	// traffic.
	//
	// When uploading a large blob using chunked upload, clients MUST first upload
	// all chunks to the CAS, then call this RPC to tell the server how those chunks
	// compose the original blob. The chunks referenced in the SpliceBlob call SHOULD be
	// available in the CAS before calling this RPC.
	//
	// If a client needs to upload a large blob and is able to split a blob into
	// chunks in such a way that reusable chunks are obtained, e.g., by means of
	// content-defined chunking, it can first determine which parts of the blob
	// are already available in the remote CAS and upload the missing chunks, and
	// then use this API to store information on how the chunks compose the
	// original blob.
	//
	// Servers which implement this functionality MUST declare that they support
	// it by setting the
	// [CacheCapabilities.splice_blob_support][build.bazel.remote.execution.v2.CacheCapabilities.splice_blob_support]
	// field accordingly.
	//
	// Clients MUST check that the server supports this capability, before using
	// it.
	//
	// In order to ensure data consistency of the CAS, the server MUST only add
	// blobs to the CAS after verifying their digests. In particular, servers MUST NOT
	// trust digests provided by the client. The server MAY accept a request as no-op
	// if the client-specified blob is already in CAS or if information on how to
	// construct the blob from chunks is available. If the client-specified blob is
	// not already in the CAS, the server MUST verify that the digest of the newly
	// created blob assembled from chunks matches the digest specified by the
	// client, and reject the request if they differ. Servers MAY choose to allow
	// overwriting existing chunk mappings or to store multiple chunk mappings for
	// the same blob.
	//
	// When blob splitting and splicing is used at the same time, the clients and
	// the server SHOULD agree out-of-band upon a chunking algorithm used by both
	// parties to benefit from each others chunk data and avoid unnecessary data
	// duplication.
	//
	// Errors:
	//
	// * `NOT_FOUND`: At least one of the blob chunks is not present in the CAS.
	// * `RESOURCE_EXHAUSTED`: There is insufficient disk quota to store the
	//   spliced blob.
	// * `INVALID_ARGUMENT`: The digest of the spliced blob is different from the
	//   provided expected digest.
	// * `ALREADY_EXISTS`: The blob already exists in CAS and the server did not
	//   extend the lifetime of the chunks specified in the request, e.g. because
	//   it prefers a different chunking and extended those instead. Clients can
	//   call [SplitBlob][build.bazel.remote.execution.v2.ContentAddressableStorage.SplitBlob]
	//   to check what chunk mapping the server is using.
	SpliceBlob(context.Context, *SpliceBlobRequest) (*SpliceBlobResponse, error)
}

// =========================================
// ContentAddressableStorage Protobuf Client
// =========================================

type contentAddressableStorageProtobufClient struct {
	client      HTTPClient
	urls        [6]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewContentAddressableStorageProtobufClient creates a Protobuf client that implements the ContentAddressableStorage interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewContentAddressableStorageProtobufClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) ContentAddressableStorage {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "build.bazel.remote.execution.v2", "ContentAddressableStorage")
	urls := [6]string{
		serviceURL + "FindMissingBlobs",
		serviceURL + "BatchUpdateBlobs",
		serviceURL + "BatchReadBlobs",
		serviceURL + "GetTree",
		serviceURL + "SplitBlob",
		serviceURL + "SpliceBlob",
	}

	return &contentAddressableStorageProtobufClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *contentAddressableStorageProtobufClient) FindMissingBlobs(ctx context.Context, in *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "FindMissingBlobs")
	caller := c.callFindMissingBlobs
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FindMissingBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FindMissingBlobsRequest) when calling interceptor")
					}
					return c.callFindMissingBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FindMissingBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FindMissingBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageProtobufClient) callFindMissingBlobs(ctx context.Context, in *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error) {
	out := new(FindMissingBlobsResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *contentAddressableStorageProtobufClient) BatchUpdateBlobs(ctx context.Context, in *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "BatchUpdateBlobs")
	caller := c.callBatchUpdateBlobs
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BatchUpdateBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BatchUpdateBlobsRequest) when calling interceptor")
					}
					return c.callBatchUpdateBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BatchUpdateBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BatchUpdateBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageProtobufClient) callBatchUpdateBlobs(ctx context.Context, in *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error) {
	out := new(BatchUpdateBlobsResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *contentAddressableStorageProtobufClient) BatchReadBlobs(ctx context.Context, in *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "BatchReadBlobs")
	caller := c.callBatchReadBlobs
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BatchReadBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BatchReadBlobsRequest) when calling interceptor")
					}
					return c.callBatchReadBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BatchReadBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BatchReadBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageProtobufClient) callBatchReadBlobs(ctx context.Context, in *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error) {
	out := new(BatchReadBlobsResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[2], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *contentAddressableStorageProtobufClient) GetTree(ctx context.Context, in *GetTreeRequest) (*GetTreeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "GetTree")
	caller := c.callGetTree
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *GetTreeRequest) (*GetTreeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTreeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTreeRequest) when calling interceptor")
					}
					return c.callGetTree(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTreeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTreeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageProtobufClient) callGetTree(ctx context.Context, in *GetTreeRequest) (*GetTreeResponse, error) {
	out := new(GetTreeResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[3], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *contentAddressableStorageProtobufClient) SplitBlob(ctx context.Context, in *SplitBlobRequest) (*SplitBlobResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "SplitBlob")
	caller := c.callSplitBlob
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *SplitBlobRequest) (*SplitBlobResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*SplitBlobRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*SplitBlobRequest) when calling interceptor")
					}
					return c.callSplitBlob(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*SplitBlobResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*SplitBlobResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageProtobufClient) callSplitBlob(ctx context.Context, in *SplitBlobRequest) (*SplitBlobResponse, error) {
	out := new(SplitBlobResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[4], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *contentAddressableStorageProtobufClient) SpliceBlob(ctx context.Context, in *SpliceBlobRequest) (*SpliceBlobResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "SpliceBlob")
	caller := c.callSpliceBlob
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *SpliceBlobRequest) (*SpliceBlobResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*SpliceBlobRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*SpliceBlobRequest) when calling interceptor")
					}
					return c.callSpliceBlob(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*SpliceBlobResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*SpliceBlobResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageProtobufClient) callSpliceBlob(ctx context.Context, in *SpliceBlobRequest) (*SpliceBlobResponse, error) {
	out := new(SpliceBlobResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[5], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// =====================================
// ContentAddressableStorage JSON Client
// =====================================

type contentAddressableStorageJSONClient struct {
	client      HTTPClient
	urls        [6]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewContentAddressableStorageJSONClient creates a JSON client that implements the ContentAddressableStorage interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewContentAddressableStorageJSONClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) ContentAddressableStorage {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "build.bazel.remote.execution.v2", "ContentAddressableStorage")
	urls := [6]string{
		serviceURL + "FindMissingBlobs",
		serviceURL + "BatchUpdateBlobs",
		serviceURL + "BatchReadBlobs",
		serviceURL + "GetTree",
		serviceURL + "SplitBlob",
		serviceURL + "SpliceBlob",
	}

	return &contentAddressableStorageJSONClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *contentAddressableStorageJSONClient) FindMissingBlobs(ctx context.Context, in *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "FindMissingBlobs")
	caller := c.callFindMissingBlobs
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FindMissingBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FindMissingBlobsRequest) when calling interceptor")
					}
					return c.callFindMissingBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FindMissingBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FindMissingBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageJSONClient) callFindMissingBlobs(ctx context.Context, in *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error) {
	out := new(FindMissingBlobsResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *contentAddressableStorageJSONClient) BatchUpdateBlobs(ctx context.Context, in *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "BatchUpdateBlobs")
	caller := c.callBatchUpdateBlobs
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BatchUpdateBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BatchUpdateBlobsRequest) when calling interceptor")
					}
					return c.callBatchUpdateBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BatchUpdateBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BatchUpdateBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageJSONClient) callBatchUpdateBlobs(ctx context.Context, in *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error) {
	out := new(BatchUpdateBlobsResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *contentAddressableStorageJSONClient) BatchReadBlobs(ctx context.Context, in *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "BatchReadBlobs")
	caller := c.callBatchReadBlobs
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BatchReadBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BatchReadBlobsRequest) when calling interceptor")
					}
					return c.callBatchReadBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BatchReadBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BatchReadBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageJSONClient) callBatchReadBlobs(ctx context.Context, in *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error) {
	out := new(BatchReadBlobsResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[2], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *contentAddressableStorageJSONClient) GetTree(ctx context.Context, in *GetTreeRequest) (*GetTreeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "GetTree")
	caller := c.callGetTree
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *GetTreeRequest) (*GetTreeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTreeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTreeRequest) when calling interceptor")
					}
					return c.callGetTree(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTreeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTreeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageJSONClient) callGetTree(ctx context.Context, in *GetTreeRequest) (*GetTreeResponse, error) {
	out := new(GetTreeResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[3], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *contentAddressableStorageJSONClient) SplitBlob(ctx context.Context, in *SplitBlobRequest) (*SplitBlobResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "SplitBlob")
	caller := c.callSplitBlob
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *SplitBlobRequest) (*SplitBlobResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*SplitBlobRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*SplitBlobRequest) when calling interceptor")
					}
					return c.callSplitBlob(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*SplitBlobResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*SplitBlobResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageJSONClient) callSplitBlob(ctx context.Context, in *SplitBlobRequest) (*SplitBlobResponse, error) {
	out := new(SplitBlobResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[4], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *contentAddressableStorageJSONClient) SpliceBlob(ctx context.Context, in *SpliceBlobRequest) (*SpliceBlobResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithMethodName(ctx, "SpliceBlob")
	caller := c.callSpliceBlob
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *SpliceBlobRequest) (*SpliceBlobResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*SpliceBlobRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*SpliceBlobRequest) when calling interceptor")
					}
					return c.callSpliceBlob(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*SpliceBlobResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*SpliceBlobResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *contentAddressableStorageJSONClient) callSpliceBlob(ctx context.Context, in *SpliceBlobRequest) (*SpliceBlobResponse, error) {
	out := new(SpliceBlobResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[5], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ========================================
// ContentAddressableStorage Server Handler
// ========================================

type contentAddressableStorageServer struct {
	ContentAddressableStorage
	interceptor      twirp.Interceptor
	hooks            *twirp.ServerHooks
	pathPrefix       string // prefix for routing
	jsonSkipDefaults bool   // do not include unpopulated fields (default values) in the response
	jsonCamelCase    bool   // JSON fields are serialized as lowerCamelCase rather than keeping the original proto names
}

// NewContentAddressableStorageServer builds a TwirpServer that can be used as an http.Handler to handle
// HTTP requests that are routed to the right method in the provided svc implementation.
// The opts are twirp.ServerOption modifiers, for example twirp.WithServerHooks(hooks).
func NewContentAddressableStorageServer(svc ContentAddressableStorage, opts ...interface{}) TwirpServer {
	serverOpts := newServerOpts(opts)

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	jsonSkipDefaults := false
	_ = serverOpts.ReadOpt("jsonSkipDefaults", &jsonSkipDefaults)
	jsonCamelCase := false
	_ = serverOpts.ReadOpt("jsonCamelCase", &jsonCamelCase)
	var pathPrefix string
	if ok := serverOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	return &contentAddressableStorageServer{
		ContentAddressableStorage: svc,
		hooks:                     serverOpts.Hooks,
		interceptor:               twirp.ChainInterceptors(serverOpts.Interceptors...),
		pathPrefix:                pathPrefix,
		jsonSkipDefaults:          jsonSkipDefaults,
		jsonCamelCase:             jsonCamelCase,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *contentAddressableStorageServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	writeError(ctx, resp, err, s.hooks)
}

// handleRequestBodyError is used to handle error when the twirp server cannot read request
func (s *contentAddressableStorageServer) handleRequestBodyError(ctx context.Context, resp http.ResponseWriter, msg string, err error) {
	if context.Canceled == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.Canceled, "failed to read request: context canceled"))
		return
	}
	if context.DeadlineExceeded == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.DeadlineExceeded, "failed to read request: deadline exceeded"))
		return
	}
	s.writeError(ctx, resp, twirp.WrapError(malformedRequestError(msg), err))
}

// ContentAddressableStoragePathPrefix is a convenience constant that may identify URL paths.
// Should be used with caution, it only matches routes generated by Twirp Go clients,
// with the default "/twirp" prefix and default CamelCase service and method names.
// More info: https://twitchtv.github.io/twirp/docs/routing.html
const ContentAddressableStoragePathPrefix = "/twirp/build.bazel.remote.execution.v2.ContentAddressableStorage/"

func (s *contentAddressableStorageServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "ContentAddressableStorage")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = callRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	// Verify path format: [<prefix>]/<package>.<Service>/<Method>
	prefix, pkgService, method := parseTwirpPath(req.URL.Path)
	if pkgService != "build.bazel.remote.execution.v2.ContentAddressableStorage" {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
	if prefix != s.pathPrefix {
		msg := fmt.Sprintf("invalid path prefix %q, expected %q, on path %q", prefix, s.pathPrefix, req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	switch method {
	case "FindMissingBlobs":
		s.serveFindMissingBlobs(ctx, resp, req)
		return
	case "BatchUpdateBlobs":
		s.serveBatchUpdateBlobs(ctx, resp, req)
		return
	case "BatchReadBlobs":
		s.serveBatchReadBlobs(ctx, resp, req)
		return
	case "GetTree":
		s.serveGetTree(ctx, resp, req)
		return
	case "SplitBlob":
		s.serveSplitBlob(ctx, resp, req)
		return
	case "SpliceBlob":
		s.serveSpliceBlob(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
}

func (s *contentAddressableStorageServer) serveFindMissingBlobs(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveFindMissingBlobsJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveFindMissingBlobsProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *contentAddressableStorageServer) serveFindMissingBlobsJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "FindMissingBlobs")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(FindMissingBlobsRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.ContentAddressableStorage.FindMissingBlobs
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FindMissingBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FindMissingBlobsRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.FindMissingBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FindMissingBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FindMissingBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *FindMissingBlobsResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *FindMissingBlobsResponse and nil error while calling FindMissingBlobs. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveFindMissingBlobsProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "FindMissingBlobs")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(FindMissingBlobsRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.ContentAddressableStorage.FindMissingBlobs
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *FindMissingBlobsRequest) (*FindMissingBlobsResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FindMissingBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FindMissingBlobsRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.FindMissingBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FindMissingBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FindMissingBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *FindMissingBlobsResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *FindMissingBlobsResponse and nil error while calling FindMissingBlobs. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveBatchUpdateBlobs(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveBatchUpdateBlobsJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveBatchUpdateBlobsProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *contentAddressableStorageServer) serveBatchUpdateBlobsJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "BatchUpdateBlobs")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(BatchUpdateBlobsRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.ContentAddressableStorage.BatchUpdateBlobs
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BatchUpdateBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BatchUpdateBlobsRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.BatchUpdateBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BatchUpdateBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BatchUpdateBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *BatchUpdateBlobsResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *BatchUpdateBlobsResponse and nil error while calling BatchUpdateBlobs. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveBatchUpdateBlobsProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "BatchUpdateBlobs")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(BatchUpdateBlobsRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.ContentAddressableStorage.BatchUpdateBlobs
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *BatchUpdateBlobsRequest) (*BatchUpdateBlobsResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BatchUpdateBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BatchUpdateBlobsRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.BatchUpdateBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BatchUpdateBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BatchUpdateBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *BatchUpdateBlobsResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *BatchUpdateBlobsResponse and nil error while calling BatchUpdateBlobs. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveBatchReadBlobs(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveBatchReadBlobsJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveBatchReadBlobsProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *contentAddressableStorageServer) serveBatchReadBlobsJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "BatchReadBlobs")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(BatchReadBlobsRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.ContentAddressableStorage.BatchReadBlobs
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BatchReadBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BatchReadBlobsRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.BatchReadBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BatchReadBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BatchReadBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *BatchReadBlobsResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *BatchReadBlobsResponse and nil error while calling BatchReadBlobs. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveBatchReadBlobsProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "BatchReadBlobs")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(BatchReadBlobsRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.ContentAddressableStorage.BatchReadBlobs
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *BatchReadBlobsRequest) (*BatchReadBlobsResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BatchReadBlobsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BatchReadBlobsRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.BatchReadBlobs(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BatchReadBlobsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BatchReadBlobsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *BatchReadBlobsResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *BatchReadBlobsResponse and nil error while calling BatchReadBlobs. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveGetTree(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveGetTreeJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveGetTreeProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *contentAddressableStorageServer) serveGetTreeJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "GetTree")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(GetTreeRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.ContentAddressableStorage.GetTree
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *GetTreeRequest) (*GetTreeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTreeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTreeRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.GetTree(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTreeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTreeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *GetTreeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetTreeResponse and nil error while calling GetTree. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveGetTreeProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "GetTree")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(GetTreeRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.ContentAddressableStorage.GetTree
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *GetTreeRequest) (*GetTreeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTreeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTreeRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.GetTree(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTreeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTreeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *GetTreeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetTreeResponse and nil error while calling GetTree. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveSplitBlob(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSplitBlobJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveSplitBlobProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *contentAddressableStorageServer) serveSplitBlobJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SplitBlob")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(SplitBlobRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.ContentAddressableStorage.SplitBlob
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *SplitBlobRequest) (*SplitBlobResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*SplitBlobRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*SplitBlobRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.SplitBlob(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*SplitBlobResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*SplitBlobResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *SplitBlobResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *SplitBlobResponse and nil error while calling SplitBlob. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveSplitBlobProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SplitBlob")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(SplitBlobRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.ContentAddressableStorage.SplitBlob
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *SplitBlobRequest) (*SplitBlobResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*SplitBlobRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*SplitBlobRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.SplitBlob(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*SplitBlobResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*SplitBlobResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *SplitBlobResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *SplitBlobResponse and nil error while calling SplitBlob. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveSpliceBlob(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSpliceBlobJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveSpliceBlobProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *contentAddressableStorageServer) serveSpliceBlobJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SpliceBlob")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(SpliceBlobRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.ContentAddressableStorage.SpliceBlob
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *SpliceBlobRequest) (*SpliceBlobResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*SpliceBlobRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*SpliceBlobRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.SpliceBlob(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*SpliceBlobResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*SpliceBlobResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *SpliceBlobResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *SpliceBlobResponse and nil error while calling SpliceBlob. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) serveSpliceBlobProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SpliceBlob")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(SpliceBlobRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.ContentAddressableStorage.SpliceBlob
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *SpliceBlobRequest) (*SpliceBlobResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*SpliceBlobRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*SpliceBlobRequest) when calling interceptor")
					}
					return s.ContentAddressableStorage.SpliceBlob(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*SpliceBlobResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*SpliceBlobResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *SpliceBlobResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *SpliceBlobResponse and nil error while calling SpliceBlob. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *contentAddressableStorageServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor0, 2
}

func (s *contentAddressableStorageServer) ProtocGenTwirpVersion() string {
	return "v8.1.3"
}

// PathPrefix returns the base service path, in the form: "/<prefix>/<package>.<Service>/"
// that is everything in a Twirp route except for the <Method>. This can be used for routing,
// for example to identify the requests that are targeted to this service in a mux.
func (s *contentAddressableStorageServer) PathPrefix() string {
	return baseServicePath(s.pathPrefix, "build.bazel.remote.execution.v2", "ContentAddressableStorage")
}

// ======================
// Capabilities Interface
// ======================

// The Capabilities service may be used by remote execution clients to query
// various server properties, in order to self-configure or return meaningful
// error messages.
//
// The query may include a particular `instance_name`, in which case the values
// returned will pertain to that instance.
type Capabilities interface {
	// GetCapabilities returns the server capabilities configuration of the
	// remote endpoint.
	// Only the capabilities of the services supported by the endpoint will
	// be returned:
	// * Execution + CAS + Action Cache endpoints should return both
	//   CacheCapabilities and ExecutionCapabilities.
	// * Execution only endpoints should return ExecutionCapabilities.
	// * CAS + Action Cache only endpoints should return CacheCapabilities.
	//
	// There are no method-specific errors.
	GetCapabilities(context.Context, *GetCapabilitiesRequest) (*ServerCapabilities, error)
}

// ============================
// Capabilities Protobuf Client
// ============================

type capabilitiesProtobufClient struct {
	client      HTTPClient
	urls        [1]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewCapabilitiesProtobufClient creates a Protobuf client that implements the Capabilities interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewCapabilitiesProtobufClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) Capabilities {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "build.bazel.remote.execution.v2", "Capabilities")
	urls := [1]string{
		serviceURL + "GetCapabilities",
	}

	return &capabilitiesProtobufClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *capabilitiesProtobufClient) GetCapabilities(ctx context.Context, in *GetCapabilitiesRequest) (*ServerCapabilities, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "Capabilities")
	ctx = ctxsetters.WithMethodName(ctx, "GetCapabilities")
	caller := c.callGetCapabilities
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *GetCapabilitiesRequest) (*ServerCapabilities, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetCapabilitiesRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetCapabilitiesRequest) when calling interceptor")
					}
					return c.callGetCapabilities(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ServerCapabilities)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ServerCapabilities) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *capabilitiesProtobufClient) callGetCapabilities(ctx context.Context, in *GetCapabilitiesRequest) (*ServerCapabilities, error) {
	out := new(ServerCapabilities)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ========================
// Capabilities JSON Client
// ========================

type capabilitiesJSONClient struct {
	client      HTTPClient
	urls        [1]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewCapabilitiesJSONClient creates a JSON client that implements the Capabilities interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewCapabilitiesJSONClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) Capabilities {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "build.bazel.remote.execution.v2", "Capabilities")
	urls := [1]string{
		serviceURL + "GetCapabilities",
	}

	return &capabilitiesJSONClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *capabilitiesJSONClient) GetCapabilities(ctx context.Context, in *GetCapabilitiesRequest) (*ServerCapabilities, error) {
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "Capabilities")
	ctx = ctxsetters.WithMethodName(ctx, "GetCapabilities")
	caller := c.callGetCapabilities
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *GetCapabilitiesRequest) (*ServerCapabilities, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetCapabilitiesRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetCapabilitiesRequest) when calling interceptor")
					}
					return c.callGetCapabilities(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ServerCapabilities)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ServerCapabilities) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *capabilitiesJSONClient) callGetCapabilities(ctx context.Context, in *GetCapabilitiesRequest) (*ServerCapabilities, error) {
	out := new(ServerCapabilities)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ===========================
// Capabilities Server Handler
// ===========================

type capabilitiesServer struct {
	Capabilities
	interceptor      twirp.Interceptor
	hooks            *twirp.ServerHooks
	pathPrefix       string // prefix for routing
	jsonSkipDefaults bool   // do not include unpopulated fields (default values) in the response
	jsonCamelCase    bool   // JSON fields are serialized as lowerCamelCase rather than keeping the original proto names
}

// NewCapabilitiesServer builds a TwirpServer that can be used as an http.Handler to handle
// HTTP requests that are routed to the right method in the provided svc implementation.
// The opts are twirp.ServerOption modifiers, for example twirp.WithServerHooks(hooks).
func NewCapabilitiesServer(svc Capabilities, opts ...interface{}) TwirpServer {
	serverOpts := newServerOpts(opts)

	// Using ReadOpt allows backwards and forwards compatibility with new options in the future
	jsonSkipDefaults := false
	_ = serverOpts.ReadOpt("jsonSkipDefaults", &jsonSkipDefaults)
	jsonCamelCase := false
	_ = serverOpts.ReadOpt("jsonCamelCase", &jsonCamelCase)
	var pathPrefix string
	if ok := serverOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	return &capabilitiesServer{
		Capabilities:     svc,
		hooks:            serverOpts.Hooks,
		interceptor:      twirp.ChainInterceptors(serverOpts.Interceptors...),
		pathPrefix:       pathPrefix,
		jsonSkipDefaults: jsonSkipDefaults,
		jsonCamelCase:    jsonCamelCase,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *capabilitiesServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	writeError(ctx, resp, err, s.hooks)
}

// handleRequestBodyError is used to handle error when the twirp server cannot read request
func (s *capabilitiesServer) handleRequestBodyError(ctx context.Context, resp http.ResponseWriter, msg string, err error) {
	if context.Canceled == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.Canceled, "failed to read request: context canceled"))
		return
	}
	if context.DeadlineExceeded == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.DeadlineExceeded, "failed to read request: deadline exceeded"))
		return
	}
	s.writeError(ctx, resp, twirp.WrapError(malformedRequestError(msg), err))
}

// CapabilitiesPathPrefix is a convenience constant that may identify URL paths.
// Should be used with caution, it only matches routes generated by Twirp Go clients,
// with the default "/twirp" prefix and default CamelCase service and method names.
// More info: https://twitchtv.github.io/twirp/docs/routing.html
const CapabilitiesPathPrefix = "/twirp/build.bazel.remote.execution.v2.Capabilities/"

func (s *capabilitiesServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "build.bazel.remote.execution.v2")
	ctx = ctxsetters.WithServiceName(ctx, "Capabilities")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = callRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	// Verify path format: [<prefix>]/<package>.<Service>/<Method>
	prefix, pkgService, method := parseTwirpPath(req.URL.Path)
	if pkgService != "build.bazel.remote.execution.v2.Capabilities" {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
	if prefix != s.pathPrefix {
		msg := fmt.Sprintf("invalid path prefix %q, expected %q, on path %q", prefix, s.pathPrefix, req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	switch method {
	case "GetCapabilities":
		s.serveGetCapabilities(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
}

func (s *capabilitiesServer) serveGetCapabilities(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveGetCapabilitiesJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveGetCapabilitiesProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *capabilitiesServer) serveGetCapabilitiesJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "GetCapabilities")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(GetCapabilitiesRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.Capabilities.GetCapabilities
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *GetCapabilitiesRequest) (*ServerCapabilities, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetCapabilitiesRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetCapabilitiesRequest) when calling interceptor")
					}
					return s.Capabilities.GetCapabilities(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ServerCapabilities)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ServerCapabilities) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *ServerCapabilities
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ServerCapabilities and nil error while calling GetCapabilities. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *capabilitiesServer) serveGetCapabilitiesProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "GetCapabilities")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := io.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(GetCapabilitiesRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.Capabilities.GetCapabilities
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *GetCapabilitiesRequest) (*ServerCapabilities, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetCapabilitiesRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetCapabilitiesRequest) when calling interceptor")
					}
					return s.Capabilities.GetCapabilities(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ServerCapabilities)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ServerCapabilities) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *ServerCapabilities
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ServerCapabilities and nil error while calling GetCapabilities. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *capabilitiesServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor0, 3
}

func (s *capabilitiesServer) ProtocGenTwirpVersion() string {
	return "v8.1.3"
}

// PathPrefix returns the base service path, in the form: "/<prefix>/<package>.<Service>/"
// that is everything in a Twirp route except for the <Method>. This can be used for routing,
// for example to identify the requests that are targeted to this service in a mux.
func (s *capabilitiesServer) PathPrefix() string {
	return baseServicePath(s.pathPrefix, "build.bazel.remote.execution.v2", "Capabilities")
}

// =====
// Utils
// =====

// HTTPClient is the interface used by generated clients to send HTTP requests.
// It is fulfilled by *(net/http).Client, which is sufficient for most users.
// Users can provide their own implementation for special retry policies.
//
// HTTPClient implementations should not follow redirects. Redirects are
// automatically disabled if *(net/http).Client is passed to client
// constructors. See the withoutRedirects function in this file for more
// details.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// TwirpServer is the interface generated server structs will support: they're
// HTTP handlers with additional methods for accessing metadata about the
// service. Those accessors are a low-level API for building reflection tools.
// Most people can think of TwirpServers as just http.Handlers.
type TwirpServer interface {
	http.Handler

	// ServiceDescriptor returns gzipped bytes describing the .proto file that
	// this service was generated from. Once unzipped, the bytes can be
	// unmarshalled as a
	// google.golang.org/protobuf/types/descriptorpb.FileDescriptorProto.
	//
	// The returned integer is the index of this particular service within that
	// FileDescriptorProto's 'Service' slice of ServiceDescriptorProtos. This is a
	// low-level field, expected to be used for reflection.
	ServiceDescriptor() ([]byte, int)

	// ProtocGenTwirpVersion is the semantic version string of the version of
	// twirp used to generate this file.
	ProtocGenTwirpVersion() string

	// PathPrefix returns the HTTP URL path prefix for all methods handled by this
	// service. This can be used with an HTTP mux to route Twirp requests.
	// The path prefix is in the form: "/<prefix>/<package>.<Service>/"
	// that is, everything in a Twirp route except for the <Method> at the end.
	PathPrefix() string
}

func newServerOpts(opts []interface{}) *twirp.ServerOptions {
	serverOpts := &twirp.ServerOptions{}
	for _, opt := range opts {
		switch o := opt.(type) {
		case twirp.ServerOption:
			o(serverOpts)
		case *twirp.ServerHooks: // backwards compatibility, allow to specify hooks as an argument
			twirp.WithServerHooks(o)(serverOpts)
		case nil: // backwards compatibility, allow nil value for the argument
			continue
		default:
			panic(fmt.Sprintf("Invalid option type %T, please use a twirp.ServerOption", o))
		}
	}
	return serverOpts
}

// WriteError writes an HTTP response with a valid Twirp error format (code, msg, meta).
// Useful outside of the Twirp server (e.g. http middleware), but does not trigger hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func WriteError(resp http.ResponseWriter, err error) {
	writeError(context.Background(), resp, err, nil)
}

// writeError writes Twirp errors in the response and triggers hooks.
func writeError(ctx context.Context, resp http.ResponseWriter, err error, hooks *twirp.ServerHooks) {
	// Convert to a twirp.Error. Non-twirp errors are converted to internal errors.
	var twerr twirp.Error
	if !errors.As(err, &twerr) {
		twerr = twirp.InternalErrorWith(err)
	}

	statusCode := twirp.ServerHTTPStatusFromErrorCode(twerr.Code())
	ctx = ctxsetters.WithStatusCode(ctx, statusCode)
	ctx = callError(ctx, hooks, twerr)

	respBody := marshalErrorToJSON(twerr)

	resp.Header().Set("Content-Type", "application/json") // Error responses are always JSON
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBody)))
	resp.WriteHeader(statusCode) // set HTTP status code and send response

	_, writeErr := resp.Write(respBody)
	if writeErr != nil {
		// We have three options here. We could log the error, call the Error
		// hook, or just silently ignore the error.
		//
		// Logging is unacceptable because we don't have a user-controlled
		// logger; writing out to stderr without permission is too rude.
		//
		// Calling the Error hook would confuse users: it would mean the Error
		// hook got called twice for one request, which is likely to lead to
		// duplicated log messages and metrics, no matter how well we document
		// the behavior.
		//
		// Silently ignoring the error is our least-bad option. It's highly
		// likely that the connection is broken and the original 'err' says
		// so anyway.
		_ = writeErr
	}

	callResponseSent(ctx, hooks)
}

// sanitizeBaseURL parses the the baseURL, and adds the "http" scheme if needed.
// If the URL is unparsable, the baseURL is returned unchanged.
func sanitizeBaseURL(baseURL string) string {
	u, err := url.Parse(baseURL)
	if err != nil {
		return baseURL // invalid URL will fail later when making requests
	}
	if u.Scheme == "" {
		u.Scheme = "http"
	}
	return u.String()
}

// baseServicePath composes the path prefix for the service (without <Method>).
// e.g.: baseServicePath("/twirp", "my.pkg", "MyService")
//
//	returns => "/twirp/my.pkg.MyService/"
//
// e.g.: baseServicePath("", "", "MyService")
//
//	returns => "/MyService/"
func baseServicePath(prefix, pkg, service string) string {
	fullServiceName := service
	if pkg != "" {
		fullServiceName = pkg + "." + service
	}
	return path.Join("/", prefix, fullServiceName) + "/"
}

// parseTwirpPath extracts path components form a valid Twirp route.
// Expected format: "[<prefix>]/<package>.<Service>/<Method>"
// e.g.: prefix, pkgService, method := parseTwirpPath("/twirp/pkg.Svc/MakeHat")
func parseTwirpPath(path string) (string, string, string) {
	parts := strings.Split(path, "/")
	if len(parts) < 2 {
		return "", "", ""
	}
	method := parts[len(parts)-1]
	pkgService := parts[len(parts)-2]
	prefix := strings.Join(parts[0:len(parts)-2], "/")
	return prefix, pkgService, method
}

// getCustomHTTPReqHeaders retrieves a copy of any headers that are set in
// a context through the twirp.WithHTTPRequestHeaders function.
// If there are no headers set, or if they have the wrong type, nil is returned.
func getCustomHTTPReqHeaders(ctx context.Context) http.Header {
	header, ok := twirp.HTTPRequestHeaders(ctx)
	if !ok || header == nil {
		return nil
	}
	copied := make(http.Header)
	for k, vv := range header {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}
	return copied
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequest("POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if customHeader := getCustomHTTPReqHeaders(ctx); customHeader != nil {
		req.Header = customHeader
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set("Twirp-Version", "v8.1.3")
	return req, nil
}

// JSON serialization for errors
type twerrJSON struct {
	Code string            `json:"code"`
	Msg  string            `json:"msg"`
	Meta map[string]string `json:"meta,omitempty"`
}

// marshalErrorToJSON returns JSON from a twirp.Error, that can be used as HTTP error response body.
// If serialization fails, it will use a descriptive Internal error instead.
func marshalErrorToJSON(twerr twirp.Error) []byte {
	// make sure that msg is not too large
	msg := twerr.Msg()
	if len(msg) > 1e6 {
		msg = msg[:1e6]
	}

	tj := twerrJSON{
		Code: string(twerr.Code()),
		Msg:  msg,
		Meta: twerr.MetaMap(),
	}

	buf, err := json.Marshal(&tj)
	if err != nil {
		buf = []byte("{\"type\": \"" + twirp.Internal + "\", \"msg\": \"There was an error but it could not be serialized into JSON\"}") // fallback
	}

	return buf
}

// errorFromResponse builds a twirp.Error from a non-200 HTTP response.
// If the response has a valid serialized Twirp error, then it's returned.
// If not, the response status code is used to generate a similar twirp
// error. See twirpErrorFromIntermediary for more info on intermediary errors.
func errorFromResponse(resp *http.Response) twirp.Error {
	statusCode := resp.StatusCode
	statusText := http.StatusText(statusCode)

	if isHTTPRedirect(statusCode) {
		// Unexpected redirect: it must be an error from an intermediary.
		// Twirp clients don't follow redirects automatically, Twirp only handles
		// POST requests, redirects should only happen on GET and HEAD requests.
		location := resp.Header.Get("Location")
		msg := fmt.Sprintf("unexpected HTTP status code %d %q received, Location=%q", statusCode, statusText, location)
		return twirpErrorFromIntermediary(statusCode, msg, location)
	}

	respBodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return wrapInternal(err, "failed to read server error response body")
	}

	var tj twerrJSON
	dec := json.NewDecoder(bytes.NewReader(respBodyBytes))
	dec.DisallowUnknownFields()
	if err := dec.Decode(&tj); err != nil || tj.Code == "" {
		// Invalid JSON response; it must be an error from an intermediary.
		msg := fmt.Sprintf("Error from intermediary with HTTP status code %d %q", statusCode, statusText)
		return twirpErrorFromIntermediary(statusCode, msg, string(respBodyBytes))
	}

	errorCode := twirp.ErrorCode(tj.Code)
	if !twirp.IsValidErrorCode(errorCode) {
		msg := "invalid type returned from server error response: " + tj.Code
		return twirp.InternalError(msg).WithMeta("body", string(respBodyBytes))
	}

	twerr := twirp.NewError(errorCode, tj.Msg)
	for k, v := range tj.Meta {
		twerr = twerr.WithMeta(k, v)
	}
	return twerr
}

// twirpErrorFromIntermediary maps HTTP errors from non-twirp sources to twirp errors.
// The mapping is similar to gRPC: https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md.
// Returned twirp Errors have some additional metadata for inspection.
func twirpErrorFromIntermediary(status int, msg string, bodyOrLocation string) twirp.Error {
	var code twirp.ErrorCode
	if isHTTPRedirect(status) { // 3xx
		code = twirp.Internal
	} else {
		switch status {
		case 400: // Bad Request
			code = twirp.Internal
		case 401: // Unauthorized
			code = twirp.Unauthenticated
		case 403: // Forbidden
			code = twirp.PermissionDenied
		case 404: // Not Found
			code = twirp.BadRoute
		case 429: // Too Many Requests
			code = twirp.ResourceExhausted
		case 502, 503, 504: // Bad Gateway, Service Unavailable, Gateway Timeout
			code = twirp.Unavailable
		default: // All other codes
			code = twirp.Unknown
		}
	}

	twerr := twirp.NewError(code, msg)
	twerr = twerr.WithMeta("http_error_from_intermediary", "true") // to easily know if this error was from intermediary
	twerr = twerr.WithMeta("status_code", strconv.Itoa(status))
	if isHTTPRedirect(status) {
		twerr = twerr.WithMeta("location", bodyOrLocation)
	} else {
		twerr = twerr.WithMeta("body", bodyOrLocation)
	}
	return twerr
}

func isHTTPRedirect(status int) bool {
	return status >= 300 && status <= 399
}

// wrapInternal wraps an error with a prefix as an Internal error.
// The original error cause is accessible by github.com/pkg/errors.Cause.
func wrapInternal(err error, prefix string) twirp.Error {
	return twirp.InternalErrorWith(&wrappedError{prefix: prefix, cause: err})
}

type wrappedError struct {
	prefix string
	cause  error
}

func (e *wrappedError) Error() string { return e.prefix + ": " + e.cause.Error() }
func (e *wrappedError) Unwrap() error { return e.cause } // for go1.13 + errors.Is/As
func (e *wrappedError) Cause() error  { return e.cause } // for github.com/pkg/errors

// ensurePanicResponses makes sure that rpc methods causing a panic still result in a Twirp Internal
// error response (status 500), and error hooks are properly called with the panic wrapped as an error.
// The panic is re-raised so it can be handled normally with middleware.
func ensurePanicResponses(ctx context.Context, resp http.ResponseWriter, hooks *twirp.ServerHooks) {
	if r := recover(); r != nil {
		// Wrap the panic as an error so it can be passed to error hooks.
		// The original error is accessible from error hooks, but not visible in the response.
		err := errFromPanic(r)
		twerr := &internalWithCause{msg: "Internal service panic", cause: err}
		// Actually write the error
		writeError(ctx, resp, twerr, hooks)
		// If possible, flush the error to the wire.
		f, ok := resp.(http.Flusher)
		if ok {
			f.Flush()
		}

		panic(r)
	}
}

// errFromPanic returns the typed error if the recovered panic is an error, otherwise formats as error.
func errFromPanic(p interface{}) error {
	if err, ok := p.(error); ok {
		return err
	}
	return fmt.Errorf("panic: %v", p)
}

// internalWithCause is a Twirp Internal error wrapping an original error cause,
// but the original error message is not exposed on Msg(). The original error
// can be checked with go1.13+ errors.Is/As, and also by (github.com/pkg/errors).Unwrap
type internalWithCause struct {
	msg   string
	cause error
}

func (e *internalWithCause) Unwrap() error                               { return e.cause } // for go1.13 + errors.Is/As
func (e *internalWithCause) Cause() error                                { return e.cause } // for github.com/pkg/errors
func (e *internalWithCause) Error() string                               { return e.msg + ": " + e.cause.Error() }
func (e *internalWithCause) Code() twirp.ErrorCode                       { return twirp.Internal }
func (e *internalWithCause) Msg() string                                 { return e.msg }
func (e *internalWithCause) Meta(key string) string                      { return "" }
func (e *internalWithCause) MetaMap() map[string]string                  { return nil }
func (e *internalWithCause) WithMeta(key string, val string) twirp.Error { return e }

// malformedRequestError is used when the twirp server cannot unmarshal a request
func malformedRequestError(msg string) twirp.Error {
	return twirp.NewError(twirp.Malformed, msg)
}

// badRouteError is used when the twirp server cannot route a request
func badRouteError(msg string, method, url string) twirp.Error {
	err := twirp.NewError(twirp.BadRoute, msg)
	err = err.WithMeta("twirp_invalid_route", method+" "+url)
	return err
}

// withoutRedirects makes sure that the POST request can not be redirected.
// The standard library will, by default, redirect requests (including POSTs) if it gets a 302 or
// 303 response, and also 301s in go1.8. It redirects by making a second request, changing the
// method to GET and removing the body. This produces very confusing error messages, so instead we
// set a redirect policy that always errors. This stops Go from executing the redirect.
//
// We have to be a little careful in case the user-provided http.Client has its own CheckRedirect
// policy - if so, we'll run through that policy first.
//
// Because this requires modifying the http.Client, we make a new copy of the client and return it.
func withoutRedirects(in *http.Client) *http.Client {
	copy := *in
	copy.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		if in.CheckRedirect != nil {
			// Run the input's redirect if it exists, in case it has side effects, but ignore any error it
			// returns, since we want to use ErrUseLastResponse.
			err := in.CheckRedirect(req, via)
			_ = err // Silly, but this makes sure generated code passes errcheck -blank, which some people use.
		}
		return http.ErrUseLastResponse
	}
	return &copy
}

// doProtobufRequest makes a Protobuf request to the remote Twirp service.
func doProtobufRequest(ctx context.Context, client HTTPClient, hooks *twirp.ClientHooks, url string, in, out proto.Message) (_ context.Context, err error) {
	reqBodyBytes, err := proto.Marshal(in)
	if err != nil {
		return ctx, wrapInternal(err, "failed to marshal proto request")
	}
	reqBody := bytes.NewBuffer(reqBodyBytes)
	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}

	req, err := newRequest(ctx, url, reqBody, "application/protobuf")
	if err != nil {
		return ctx, wrapInternal(err, "could not build request")
	}
	ctx, err = callClientRequestPrepared(ctx, hooks, req)
	if err != nil {
		return ctx, err
	}

	req = req.WithContext(ctx)
	resp, err := client.Do(req)
	if err != nil {
		return ctx, wrapInternal(err, "failed to do request")
	}
	defer func() { _ = resp.Body.Close() }()

	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}

	if resp.StatusCode != 200 {
		return ctx, errorFromResponse(resp)
	}

	respBodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return ctx, wrapInternal(err, "failed to read response body")
	}
	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}

	if err = proto.Unmarshal(respBodyBytes, out); err != nil {
		return ctx, wrapInternal(err, "failed to unmarshal proto response")
	}
	return ctx, nil
}

// doJSONRequest makes a JSON request to the remote Twirp service.
func doJSONRequest(ctx context.Context, client HTTPClient, hooks *twirp.ClientHooks, url string, in, out proto.Message) (_ context.Context, err error) {
	marshaler := &protojson.MarshalOptions{UseProtoNames: true}
	reqBytes, err := marshaler.Marshal(in)
	if err != nil {
		return ctx, wrapInternal(err, "failed to marshal json request")
	}
	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}

	req, err := newRequest(ctx, url, bytes.NewReader(reqBytes), "application/json")
	if err != nil {
		return ctx, wrapInternal(err, "could not build request")
	}
	ctx, err = callClientRequestPrepared(ctx, hooks, req)
	if err != nil {
		return ctx, err
	}

	req = req.WithContext(ctx)
	resp, err := client.Do(req)
	if err != nil {
		return ctx, wrapInternal(err, "failed to do request")
	}

	defer func() {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = wrapInternal(cerr, "failed to close response body")
		}
	}()

	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}

	if resp.StatusCode != 200 {
		return ctx, errorFromResponse(resp)
	}

	d := json.NewDecoder(resp.Body)
	rawRespBody := json.RawMessage{}
	if err := d.Decode(&rawRespBody); err != nil {
		return ctx, wrapInternal(err, "failed to unmarshal json response")
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawRespBody, out); err != nil {
		return ctx, wrapInternal(err, "failed to unmarshal json response")
	}
	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}
	return ctx, nil
}

// Call twirp.ServerHooks.RequestReceived if the hook is available
func callRequestReceived(ctx context.Context, h *twirp.ServerHooks) (context.Context, error) {
	if h == nil || h.RequestReceived == nil {
		return ctx, nil
	}
	return h.RequestReceived(ctx)
}

// Call twirp.ServerHooks.RequestRouted if the hook is available
func callRequestRouted(ctx context.Context, h *twirp.ServerHooks) (context.Context, error) {
	if h == nil || h.RequestRouted == nil {
		return ctx, nil
	}
	return h.RequestRouted(ctx)
}

// Call twirp.ServerHooks.ResponsePrepared if the hook is available
func callResponsePrepared(ctx context.Context, h *twirp.ServerHooks) context.Context {
	if h == nil || h.ResponsePrepared == nil {
		return ctx
	}
	return h.ResponsePrepared(ctx)
}

// Call twirp.ServerHooks.ResponseSent if the hook is available
func callResponseSent(ctx context.Context, h *twirp.ServerHooks) {
	if h == nil || h.ResponseSent == nil {
		return
	}
	h.ResponseSent(ctx)
}

// Call twirp.ServerHooks.Error if the hook is available
func callError(ctx context.Context, h *twirp.ServerHooks, err twirp.Error) context.Context {
	if h == nil || h.Error == nil {
		return ctx
	}
	return h.Error(ctx, err)
}

func callClientResponseReceived(ctx context.Context, h *twirp.ClientHooks) {
	if h == nil || h.ResponseReceived == nil {
		return
	}
	h.ResponseReceived(ctx)
}

func callClientRequestPrepared(ctx context.Context, h *twirp.ClientHooks, req *http.Request) (context.Context, error) {
	if h == nil || h.RequestPrepared == nil {
		return ctx, nil
	}
	return h.RequestPrepared(ctx, req)
}

func callClientError(ctx context.Context, h *twirp.ClientHooks, err twirp.Error) {
	if h == nil || h.Error == nil {
		return
	}
	h.Error(ctx, err)
}

var twirpFileDescriptor0 = []byte{
	// 4170 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x3b, 0x4b, 0x6c, 0x23, 0xc9,
	0x75, 0xdb, 0xfc, 0xf3, 0x91, 0x12, 0x5b, 0x35, 0xfa, 0x70, 0x38, 0x3b, 0x3b, 0x33, 0xbd, 0x58,
	0xaf, 0xac, 0xdd, 0x25, 0x67, 0xa8, 0x9d, 0xf5, 0x58, 0x8e, 0x77, 0xa3, 0x0f, 0xb5, 0xa3, 0x59,
	0xfd, 0xdc, 0xa4, 0xe6, 0xb3, 0xb6, 0xb7, 0xdd, 0x62, 0x97, 0xa8, 0xc6, 0x34, 0xbb, 0xb9, 0xdd,
	0x4d, 0x8d, 0xb4, 0x8b, 0xc9, 0x21, 0x17, 0x07, 0x3e, 0x38, 0x87, 0xe4, 0x90, 0xc4, 0xc8, 0x25,
	0x37, 0x07, 0x39, 0x24, 0x40, 0x80, 0x24, 0x40, 0x02, 0x04, 0x39, 0x39, 0x40, 0x90, 0x83, 0x0d,
	0x24, 0x48, 0x0e, 0x09, 0x02, 0x24, 0x40, 0xe0, 0xe4, 0x9a, 0x63, 0x80, 0xa0, 0x3e, 0xfd, 0x23,
	0x5b, 0x43, 0x52, 0xa3, 0x89, 0x7d, 0x12, 0xfb, 0x55, 0xbd, 0xff, 0xab, 0x57, 0xaf, 0x5e, 0x95,
	0x60, 0x45, 0xed, 0xe9, 0xb5, 0xc3, 0xbe, 0x6e, 0x68, 0xb5, 0x43, 0xf5, 0x0b, 0x6c, 0xd4, 0x6c,
	0xdc, 0xb5, 0x5c, 0x5c, 0xc3, 0xa7, 0xb8, 0xdd, 0x77, 0x75, 0xcb, 0xac, 0x9d, 0xd4, 0x39, 0x4c,
	0xf1, 0x61, 0xd5, 0x9e, 0x6d, 0xb9, 0x16, 0xba, 0x41, 0xf1, 0xaa, 0x14, 0xaf, 0xca, 0xe6, 0x54,
	0x83, 0x39, 0x27, 0xf5, 0xca, 0x9b, 0x83, 0xc4, 0x1d, 0xdc, 0x3d, 0xc1, 0x36, 0xff, 0xc3, 0xa8,
	0x54, 0x5e, 0xef, 0x58, 0x56, 0xc7, 0xc0, 0x35, 0x32, 0x57, 0x35, 0x4d, 0xcb, 0x55, 0x09, 0xba,
	0xc3, 0x47, 0xdf, 0xe4, 0xa3, 0x86, 0x65, 0x76, 0xec, 0xbe, 0x69, 0xea, 0x66, 0xa7, 0x66, 0xf5,
	0xb0, 0x1d, 0x99, 0x74, 0x95, 0x4f, 0xa2, 0x5f, 0x87, 0xfd, 0xa3, 0x9a, 0x6a, 0x9e, 0xf1, 0xa1,
	0x37, 0x06, 0x87, 0xb4, 0x3e, 0xc3, 0xe5, 0xe3, 0x37, 0x06, 0xc7, 0x5d, 0xbd, 0x8b, 0x1d, 0x57,
	0xed, 0xf6, 0xce, 0x23, 0xf0, 0xcc, 0x56, 0x7b, 0x3d, 0x6c, 0x7b, 0xbc, 0x17, 0xf8, 0xb8, 0xdd,
	0x6b, 0xd7, 0x1c, 0x57, 0x75, 0xfb, 0x7c, 0x40, 0xfa, 0xaf, 0x04, 0x64, 0x56, 0xdb, 0x84, 0x15,
	0xda, 0x85, 0xe9, 0xb6, 0xd5, 0xed, 0xaa, 0xa6, 0xa6, 0x68, 0x7a, 0x07, 0x3b, 0x6e, 0x59, 0xb8,
	0x29, 0x2c, 0x16, 0xea, 0x6f, 0x57, 0x47, 0x58, 0xb0, 0xba, 0x41, 0xa7, 0xcb, 0x53, 0x1c, 0x9d,
	0x7d, 0xa2, 0x26, 0xcc, 0xe8, 0x66, 0xaf, 0xef, 0x2a, 0xb6, 0x65, 0xb9, 0x1e, 0xc9, 0xc4, 0x64,
	0x24, 0x4b, 0x94, 0x82, 0x6c, 0x59, 0x2e, 0x27, 0xba, 0x0c, 0x59, 0xa2, 0xbb, 0xd5, 0x77, 0xcb,
	0x19, 0x4a, 0xea, 0x6a, 0x95, 0xa9, 0x56, 0xf5, 0x54, 0xaf, 0x6e, 0x70, 0xdb, 0xc9, 0xde, 0x4c,
	0x74, 0x13, 0x8a, 0x9a, 0xa5, 0x98, 0x96, 0xab, 0xb4, 0xd5, 0xf6, 0x31, 0x2e, 0x67, 0x6f, 0x0a,
	0x8b, 0x39, 0x19, 0x34, 0x6b, 0xd7, 0x72, 0xd7, 0x09, 0x04, 0x21, 0x48, 0x39, 0xaa, 0xe1, 0x96,
	0xf3, 0x37, 0x85, 0xc5, 0xa2, 0x4c, 0x7f, 0xa3, 0x06, 0xe4, 0x7a, 0x86, 0xea, 0x1e, 0x59, 0x76,
	0xb7, 0x0c, 0x94, 0xd7, 0x57, 0x47, 0x8a, 0xbd, 0xcf, 0x11, 0x64, 0x1f, 0xf5, 0x41, 0x2a, 0x97,
	0x14, 0x33, 0x0f, 0x52, 0xb9, 0x9c, 0x98, 0x97, 0x7e, 0x9a, 0x86, 0xec, 0x3a, 0x33, 0x12, 0x7a,
	0x1d, 0xf2, 0xaa, 0xdd, 0xe9, 0x77, 0xb1, 0xe9, 0x3a, 0x65, 0xe1, 0x66, 0x72, 0x31, 0x2f, 0x07,
	0x00, 0xf4, 0x39, 0xcc, 0x61, 0xf3, 0x44, 0xb7, 0x2d, 0x93, 0x7c, 0x2b, 0x27, 0xaa, 0xad, 0xab,
	0x87, 0x06, 0x76, 0xca, 0x89, 0x9b, 0xc9, 0xc5, 0x42, 0xfd, 0x57, 0x46, 0x4a, 0xc2, 0xd9, 0x54,
	0x1b, 0x01, 0x95, 0x87, 0x9c, 0x88, 0x3c, 0x8b, 0x87, 0x81, 0x0e, 0x7a, 0x0b, 0x8a, 0x56, 0xdf,
	0x25, 0x0e, 0x3b, 0xd2, 0x09, 0xa7, 0x24, 0x91, 0x69, 0x2d, 0x51, 0x16, 0xe4, 0x02, 0x83, 0x6f,
	0x12, 0x30, 0xba, 0x03, 0x88, 0x4f, 0xd3, 0x74, 0x1b, 0xb7, 0x5d, 0xcb, 0xd6, 0xb1, 0x53, 0x4e,
	0xf9, 0x93, 0x67, 0xd8, 0xe8, 0x46, 0x30, 0x88, 0x6e, 0xf9, 0x94, 0x7b, 0xaa, 0x7b, 0xec, 0x94,
	0xb3, 0x54, 0x5b, 0x4e, 0x75, 0x9f, 0x80, 0xd0, 0x56, 0xc8, 0xd8, 0xe9, 0x09, 0x8d, 0x4d, 0xd9,
	0xfa, 0xe8, 0xe8, 0x1d, 0x98, 0x79, 0x66, 0xd9, 0x4f, 0x75, 0xb3, 0xe3, 0x4b, 0x78, 0x46, 0x83,
	0x25, 0x2f, 0x8b, 0x7c, 0xc0, 0x13, 0xee, 0x0c, 0xbd, 0x0f, 0xf3, 0x5c, 0x34, 0xd3, 0xd2, 0xb0,
	0xd2, 0xb3, 0xc9, 0xb2, 0x75, 0x89, 0x46, 0x39, 0x2a, 0xe4, 0x2c, 0x1b, 0xdd, 0xb5, 0x34, 0xbc,
	0xef, 0x8f, 0xa1, 0x13, 0x58, 0x18, 0xb0, 0xc1, 0x99, 0x42, 0x78, 0xab, 0x2c, 0x82, 0xa6, 0xeb,
	0x1f, 0x8e, 0xed, 0x9f, 0xbd, 0x88, 0xb5, 0xce, 0x36, 0x29, 0x15, 0x79, 0xce, 0x8a, 0x03, 0x57,
	0x3e, 0x82, 0x2b, 0x31, 0xfe, 0x24, 0xd1, 0x6b, 0xaa, 0x5d, 0x4c, 0xd7, 0x6b, 0x5e, 0xa6, 0xbf,
	0xd1, 0x2c, 0xa4, 0x4f, 0x54, 0xa3, 0x8f, 0xe9, 0x8a, 0xcb, 0xcb, 0xec, 0x43, 0x92, 0x61, 0x2e,
	0x96, 0x21, 0x9a, 0x82, 0x7c, 0x4b, 0x6e, 0x34, 0x94, 0xbd, 0xdd, 0xed, 0x27, 0xe2, 0x6b, 0x08,
	0xc1, 0xf4, 0xc6, 0x96, 0xdc, 0x58, 0x6f, 0xed, 0xc9, 0x4f, 0x18, 0x4c, 0x40, 0xf3, 0x80, 0xe8,
	0x94, 0xd5, 0xdd, 0x0d, 0xc5, 0x1f, 0x14, 0x13, 0xd2, 0x6f, 0x0b, 0x90, 0xf3, 0x5c, 0x81, 0x64,
	0x80, 0x90, 0x0d, 0x05, 0x1a, 0xac, 0xf5, 0xb1, 0x3d, 0x59, 0xe5, 0x36, 0x3e, 0x93, 0x43, 0x54,
	0x2a, 0xef, 0x43, 0xce, 0x83, 0x4f, 0xa0, 0xea, 0x4f, 0x12, 0x90, 0x0f, 0xfc, 0xfc, 0x11, 0xa4,
	0x59, 0x54, 0x33, 0x91, 0x46, 0x07, 0x17, 0x09, 0x76, 0xe2, 0x75, 0x99, 0xe1, 0xa1, 0x7d, 0x28,
	0x84, 0xe3, 0x9d, 0x2d, 0xc3, 0xea, 0x18, 0x79, 0x8c, 0x4b, 0x40, 0x69, 0x85, 0x49, 0xa0, 0xfb,
	0x90, 0x73, 0xce, 0xba, 0x86, 0x6e, 0x3e, 0x65, 0x6b, 0xad, 0x50, 0x7f, 0x77, 0x24, 0xb9, 0x26,
	0x43, 0xa0, 0xc4, 0x7c, 0x6c, 0xf4, 0x18, 0x4a, 0x83, 0xd1, 0xcb, 0xd6, 0x50, 0x6d, 0x24, 0xc1,
	0x68, 0x60, 0xcb, 0xd3, 0x66, 0xe4, 0xfb, 0x41, 0x2a, 0x97, 0x12, 0xd3, 0xd2, 0x3d, 0x28, 0x86,
	0xe6, 0x4d, 0xe2, 0x84, 0xbf, 0x13, 0x60, 0x7a, 0x60, 0xed, 0xec, 0xc4, 0x44, 0xc8, 0x7b, 0x93,
	0xc8, 0x19, 0x09, 0x0e, 0x74, 0x1b, 0xd2, 0x5d, 0x92, 0xe7, 0xf9, 0xce, 0x52, 0x19, 0xda, 0x0e,
	0x5a, 0xde, 0x56, 0x29, 0xb3, 0x89, 0xe8, 0xeb, 0x90, 0xef, 0x9b, 0xfa, 0xa9, 0xd2, 0xb5, 0x34,
	0x5c, 0x4e, 0x52, 0xac, 0xd7, 0x87, 0xb0, 0x0e, 0xb6, 0x4c, 0x77, 0xb9, 0xfe, 0x90, 0x28, 0x21,
	0xe7, 0xc8, 0xf4, 0x1d, 0x4b, 0xc3, 0xd2, 0xcf, 0x05, 0xc8, 0x79, 0x81, 0x11, 0x6b, 0x85, 0x8f,
	0x20, 0x73, 0xb1, 0x8d, 0x8e, 0xa3, 0xa1, 0x37, 0x61, 0x4a, 0x77, 0x78, 0x0d, 0x43, 0xd6, 0x76,
	0x39, 0x45, 0xf7, 0xaa, 0xa2, 0xee, 0x34, 0x7c, 0x58, 0x9c, 0xbf, 0x33, 0x97, 0xe5, 0xef, 0xa4,
	0x98, 0x7a, 0x90, 0xca, 0xa5, 0xc5, 0x8c, 0xa4, 0xc1, 0x54, 0x24, 0x7a, 0x5f, 0x89, 0xc2, 0xd2,
	0xef, 0x0a, 0x50, 0x08, 0x45, 0x75, 0x2c, 0x93, 0x79, 0xc8, 0xb8, 0xaa, 0xdd, 0xc1, 0x2e, 0x0f,
	0x2e, 0xfe, 0x15, 0x67, 0x87, 0xd4, 0x25, 0xda, 0x41, 0xfa, 0x06, 0x64, 0x78, 0xd9, 0x81, 0x20,
	0x75, 0xac, 0x3a, 0xc7, 0x9e, 0x54, 0xe4, 0x37, 0xba, 0x0e, 0xe0, 0xe8, 0x5f, 0x60, 0xe5, 0xf0,
	0xcc, 0xa5, 0x09, 0x41, 0x58, 0x4c, 0xca, 0x79, 0x02, 0x59, 0x23, 0x00, 0xe9, 0x7f, 0xb3, 0x30,
	0xcf, 0x7c, 0x86, 0x35, 0x56, 0x61, 0xed, 0x60, 0x57, 0xd5, 0x54, 0x57, 0x25, 0xfa, 0x90, 0x8d,
	0x08, 0xdb, 0x9c, 0x1e, 0xff, 0x42, 0x0d, 0x10, 0x3f, 0xef, 0xe3, 0x3e, 0xd6, 0x14, 0xbf, 0xbe,
	0x1b, 0x23, 0xac, 0x4b, 0x0c, 0xc7, 0x07, 0xa0, 0x7d, 0x98, 0x67, 0x04, 0x15, 0xc7, 0x55, 0x6d,
	0x37, 0x44, 0x2c, 0x39, 0x92, 0xd8, 0x2c, 0xc3, 0x6c, 0x12, 0xc4, 0x80, 0xe2, 0x63, 0xa8, 0x70,
	0x8a, 0x6d, 0xab, 0xdb, 0x33, 0xb0, 0x1b, 0x11, 0x31, 0x35, 0x92, 0x6a, 0x99, 0x61, 0xaf, 0x7b,
	0xc8, 0x01, 0xe5, 0x27, 0x70, 0x8d, 0x15, 0x89, 0x47, 0xd8, 0x6d, 0x1f, 0x0f, 0x09, 0x9c, 0x1e,
	0x4d, 0x9a, 0xa2, 0x6f, 0x12, 0xec, 0x01, 0xa1, 0x55, 0xb8, 0x11, 0x26, 0x1d, 0x27, 0x79, 0x66,
	0x24, 0xf9, 0xd7, 0x03, 0xf2, 0x31, 0xd2, 0x3f, 0x84, 0xab, 0x7e, 0x54, 0x0d, 0xc9, 0x9e, 0x1d,
	0x49, 0x7c, 0xc1, 0x47, 0x1e, 0x10, 0xfd, 0x33, 0xb8, 0x1e, 0xd0, 0x8d, 0x13, 0x3c, 0x37, 0x92,
	0xf6, 0x35, 0x9f, 0x40, 0x8c, 0xdc, 0x8f, 0xa0, 0x72, 0xa2, 0xdb, 0x6e, 0x5f, 0x35, 0x82, 0xe3,
	0x92, 0xe2, 0x9d, 0x39, 0xca, 0xc5, 0x51, 0x85, 0x75, 0x99, 0x23, 0x37, 0x3c, 0x5c, 0x6f, 0x04,
	0x7d, 0x17, 0xae, 0xf3, 0xc2, 0xa8, 0xdf, 0x33, 0x2c, 0x55, 0x1b, 0x32, 0x4a, 0x7e, 0xa4, 0xe0,
	0x15, 0x46, 0xe0, 0x80, 0xe2, 0x0f, 0xd8, 0x05, 0xc3, 0xad, 0x28, 0xf9, 0x38, 0xdb, 0xc0, 0x48,
	0x16, 0x6f, 0x84, 0x59, 0xc4, 0x98, 0x67, 0x1d, 0x90, 0xda, 0x3f, 0xd5, 0x0d, 0x5d, 0xb5, 0xcf,
	0x94, 0x2e, 0x5f, 0xb5, 0xe5, 0x02, 0xdd, 0xaa, 0x66, 0x87, 0xe8, 0xae, 0x9a, 0x67, 0xf2, 0x8c,
	0x3f, 0xdf, 0x5b, 0xe4, 0xd2, 0xcf, 0x32, 0x50, 0x64, 0xeb, 0x5e, 0xc6, 0x4e, 0xdf, 0x70, 0xd1,
	0xee, 0x40, 0x7d, 0xcd, 0x4a, 0x88, 0x77, 0x46, 0xa6, 0xaa, 0x3d, 0xbf, 0xf8, 0x8e, 0x16, 0xe2,
	0x1a, 0xcc, 0x86, 0xe8, 0x29, 0x7e, 0x2d, 0x01, 0x63, 0x96, 0x26, 0x8c, 0x2e, 0xcf, 0xbd, 0xb4,
	0x86, 0x46, 0x01, 0xf9, 0xa6, 0x57, 0x5b, 0x3c, 0x82, 0x12, 0xe7, 0xe2, 0x33, 0x28, 0x5e, 0x84,
	0x81, 0x3c, 0x6d, 0x85, 0x3f, 0x1d, 0xa4, 0xc4, 0x9e, 0x23, 0x58, 0x21, 0x74, 0x7b, 0x4c, 0xda,
	0xfe, 0xfe, 0x14, 0x77, 0xea, 0x30, 0xe1, 0xea, 0x50, 0x91, 0xee, 0xeb, 0x50, 0xb8, 0xb0, 0x91,
	0x16, 0x06, 0x4a, 0x73, 0x5f, 0xa1, 0x6b, 0x90, 0xc7, 0xa7, 0xba, 0xab, 0xb4, 0x49, 0x5d, 0x41,
	0x72, 0x62, 0x5a, 0xce, 0x11, 0xc0, 0x3a, 0xd9, 0xd6, 0xc8, 0x66, 0xe1, 0x6a, 0x16, 0x39, 0x0d,
	0xab, 0xcf, 0x68, 0x5a, 0x2b, 0xca, 0x79, 0x06, 0x91, 0xd5, 0x67, 0x68, 0x1b, 0xa6, 0xf8, 0x30,
	0xdf, 0x4d, 0x33, 0x93, 0xed, 0xa6, 0x45, 0x86, 0xcd, 0x77, 0x2b, 0xc6, 0x0c, 0xdb, 0x36, 0x65,
	0x96, 0xf5, 0x99, 0x61, 0xdb, 0x0e, 0x98, 0x91, 0x61, 0xce, 0x2c, 0x37, 0x39, 0x33, 0x6c, 0xdb,
	0x9c, 0xd9, 0x11, 0xa0, 0x20, 0x87, 0xf8, 0x8b, 0x85, 0xad, 0xf3, 0xaf, 0x8d, 0x24, 0x19, 0xbf,
	0x43, 0xca, 0x33, 0xfe, 0x24, 0x0f, 0xf4, 0x20, 0x95, 0x13, 0xc4, 0x84, 0xf4, 0x1b, 0x09, 0x80,
	0x60, 0x41, 0x90, 0x7d, 0x99, 0x1c, 0x29, 0xbd, 0x7d, 0x99, 0xfc, 0xfe, 0x7f, 0xaa, 0xc1, 0x2a,
	0x90, 0x6b, 0x5b, 0xa6, 0x4b, 0x4f, 0xef, 0xcc, 0x9d, 0xfe, 0x77, 0x5c, 0x5d, 0x92, 0xbd, 0xdc,
	0xfa, 0x2c, 0x23, 0x66, 0xa5, 0x1f, 0x0a, 0x90, 0x6a, 0xd9, 0x18, 0xa3, 0x0f, 0x21, 0x65, 0x5b,
	0x96, 0xd7, 0xae, 0x59, 0x1a, 0xff, 0x4c, 0x22, 0x53, 0x3c, 0xb4, 0x09, 0xb9, 0xf6, 0xb1, 0x6e,
	0x68, 0x36, 0x36, 0x79, 0x52, 0x9a, 0x84, 0x86, 0x8f, 0x2b, 0xfd, 0x20, 0x01, 0xa5, 0x81, 0x75,
	0x19, 0xeb, 0xa0, 0xfb, 0x50, 0x70, 0x6d, 0x8c, 0xbd, 0xe8, 0x4b, 0x4e, 0xe6, 0x25, 0x20, 0xb8,
	0x3c, 0xf6, 0x3e, 0x80, 0x05, 0xdd, 0x51, 0x5c, 0xab, 0x67, 0x19, 0x56, 0x47, 0x6f, 0xab, 0x86,
	0x71, 0xa6, 0x38, 0x96, 0xed, 0x62, 0x8d, 0xfb, 0x6c, 0x4e, 0x77, 0x5a, 0xe1, 0xd1, 0x26, 0x1d,
	0x44, 0xdf, 0x86, 0x39, 0xde, 0x94, 0xf2, 0x12, 0x03, 0x97, 0x25, 0x3d, 0x99, 0x2c, 0x57, 0x6c,
	0xda, 0x99, 0xe2, 0x44, 0x18, 0xf0, 0x41, 0x2a, 0x97, 0x10, 0x93, 0xd2, 0x8f, 0x04, 0x98, 0x8a,
	0x24, 0x8f, 0x58, 0x53, 0xfc, 0xa2, 0x2a, 0xdb, 0xf7, 0xa0, 0xe4, 0x6f, 0xde, 0xfb, 0x96, 0xa1,
	0xb7, 0xcf, 0x48, 0x40, 0xf7, 0x6c, 0xdd, 0xb2, 0x75, 0xf7, 0x8c, 0x8a, 0x98, 0x96, 0xfd, 0x6f,
	0xe9, 0x36, 0x20, 0xb6, 0x89, 0x39, 0xb4, 0x5d, 0x36, 0x06, 0xc6, 0xbf, 0xa6, 0x60, 0x9a, 0xaf,
	0x6d, 0x19, 0x7f, 0xde, 0xf7, 0x96, 0x95, 0xe9, 0xb8, 0xaa, 0xd9, 0xc6, 0x4a, 0xa8, 0xc4, 0x2f,
	0x7a, 0xc0, 0x5d, 0x52, 0xea, 0x2f, 0xc1, 0x8c, 0xf3, 0x54, 0xef, 0xb1, 0x46, 0x9d, 0x62, 0x58,
	0xd6, 0xd3, 0x3e, 0x2b, 0x5b, 0x73, 0x72, 0x89, 0x0c, 0x50, 0xfe, 0xdb, 0x14, 0x4c, 0xf2, 0x98,
	0xda, 0x66, 0xa5, 0xcb, 0xc5, 0x92, 0x26, 0xc3, 0xe6, 0xb1, 0xf4, 0x6d, 0x10, 0x83, 0x3c, 0xd6,
	0xa3, 0x1a, 0xf2, 0x55, 0x7b, 0x7b, 0xcc, 0x2c, 0xe6, 0xdb, 0x52, 0x2e, 0xe1, 0x01, 0xe3, 0x62,
	0x98, 0xb5, 0x99, 0x01, 0xb9, 0x66, 0x9c, 0x01, 0xcb, 0xbc, 0xcb, 0x23, 0x19, 0x0c, 0x5b, 0x5f,
	0x46, 0xf6, 0xb0, 0x47, 0x3e, 0x83, 0x12, 0x33, 0x85, 0x72, 0xd4, 0x37, 0xa9, 0x72, 0xbc, 0x1f,
	0x75, 0x77, 0x4c, 0x9b, 0x6c, 0x72, 0xb4, 0x2a, 0x3b, 0xf9, 0x4e, 0x6b, 0x11, 0x28, 0x73, 0xa1,
	0xa1, 0x9b, 0x58, 0x61, 0xfb, 0x0d, 0xad, 0xb5, 0x48, 0x66, 0xa4, 0xc0, 0x26, 0x85, 0x45, 0x27,
	0x61, 0xdb, 0x2e, 0x17, 0x06, 0x26, 0x61, 0xdb, 0x46, 0x55, 0xb8, 0xc2, 0x27, 0x45, 0x6a, 0xa2,
	0x22, 0x6d, 0xba, 0xcd, 0xb0, 0xa1, 0x20, 0xcf, 0x3b, 0x6c, 0x51, 0xb1, 0x76, 0x04, 0x3f, 0x9e,
	0x7e, 0x0e, 0xd9, 0x6d, 0xab, 0x43, 0x77, 0x81, 0x20, 0xe3, 0x0b, 0x17, 0xcb, 0xf8, 0x6f, 0xc1,
	0xf4, 0x71, 0xbf, 0xab, 0x9a, 0x8a, 0x8d, 0x55, 0x8d, 0xa6, 0xfc, 0x04, 0x95, 0x79, 0x8a, 0x42,
	0x65, 0x0e, 0x94, 0x7e, 0x33, 0xe9, 0x2d, 0x1b, 0x2c, 0x63, 0xa7, 0x67, 0x99, 0x0e, 0x46, 0x0d,
	0xc8, 0x30, 0x47, 0x70, 0xde, 0xa3, 0x5b, 0x19, 0xe1, 0xa2, 0x50, 0xe6, 0xc8, 0xc4, 0x68, 0x34,
	0x30, 0x34, 0x85, 0x53, 0x63, 0x02, 0x14, 0x19, 0x90, 0x57, 0x90, 0x4b, 0x90, 0x61, 0xcd, 0x7b,
	0x9e, 0x33, 0x91, 0x57, 0x8b, 0xda, 0xbd, 0x76, 0xb5, 0x49, 0x47, 0x64, 0x3e, 0x03, 0xa9, 0x50,
	0x70, 0xb0, 0x7d, 0x82, 0x6d, 0xc5, 0xb0, 0x3a, 0xac, 0x3f, 0x5b, 0xa8, 0xff, 0xea, 0xb8, 0xfb,
	0xb1, 0xa7, 0x5e, 0xb5, 0x49, 0x69, 0x6c, 0x5b, 0x1d, 0xa7, 0x61, 0xba, 0xf6, 0x99, 0x0c, 0x8e,
	0x0f, 0x40, 0x65, 0xc8, 0x76, 0xb1, 0xe3, 0xa8, 0x1d, 0x4c, 0xf3, 0x66, 0x5e, 0xf6, 0x3e, 0x2b,
	0x1d, 0x28, 0x0d, 0x20, 0x22, 0x11, 0x92, 0x4f, 0xf1, 0x19, 0x5f, 0xf3, 0xe4, 0x27, 0xfa, 0x30,
	0xdc, 0x31, 0x2a, 0xd4, 0x17, 0x47, 0xca, 0xc6, 0xdd, 0xcd, 0x7b, 0x4b, 0x2b, 0x89, 0x7b, 0x82,
	0xa4, 0x7a, 0x59, 0x86, 0x9d, 0xa1, 0x3a, 0x58, 0xda, 0x83, 0x34, 0x8d, 0x5d, 0x54, 0x80, 0xec,
	0xc1, 0xee, 0x27, 0xbb, 0x7b, 0x8f, 0x76, 0xc5, 0xd7, 0x50, 0x09, 0x0a, 0xeb, 0xab, 0xeb, 0xf7,
	0x1b, 0xca, 0xfa, 0xfd, 0xc6, 0xfa, 0x27, 0xa2, 0x80, 0x00, 0x32, 0xdf, 0x3a, 0x68, 0x1c, 0x34,
	0x36, 0xc4, 0x04, 0x9a, 0x82, 0x7c, 0xe3, 0x71, 0x63, 0xfd, 0xa0, 0xb5, 0xb5, 0xfb, 0xb1, 0x98,
	0x24, 0x9f, 0xeb, 0x7b, 0x3b, 0xfb, 0xdb, 0x8d, 0x56, 0x63, 0x43, 0x4c, 0x49, 0xff, 0x99, 0x84,
	0x32, 0xb7, 0xca, 0x9e, 0x77, 0xa5, 0xe3, 0x9f, 0xe4, 0x3f, 0x81, 0xb4, 0x43, 0xd8, 0x52, 0xbd,
	0xc6, 0x59, 0x66, 0x51, 0x69, 0xf9, 0x32, 0x63, 0x34, 0x86, 0xf3, 0x59, 0xe2, 0x65, 0xf2, 0xd9,
	0xbb, 0x80, 0x78, 0x49, 0xe9, 0xb8, 0x36, 0x56, 0xbb, 0x2c, 0xe7, 0x26, 0x59, 0x1f, 0x9c, 0x8d,
	0x34, 0xe9, 0x00, 0xcd, 0xbb, 0x6c, 0x36, 0xa9, 0x09, 0xc3, 0xb3, 0x53, 0xfe, 0x6c, 0x6c, 0xdb,
	0xa1, 0xd9, 0x7d, 0xa8, 0xf4, 0x54, 0xdb, 0xd5, 0x23, 0xe7, 0x47, 0xbf, 0xf6, 0x4b, 0xbf, 0x5c,
	0xed, 0x57, 0xe6, 0xa4, 0x1b, 0x83, 0x25, 0x60, 0x5c, 0x7a, 0xcb, 0x5c, 0x62, 0x7a, 0x93, 0x96,
	0x60, 0xf6, 0x91, 0xaa, 0xbb, 0x3e, 0x63, 0x6f, 0xe7, 0x8a, 0xe9, 0x49, 0x49, 0xff, 0x91, 0x80,
	0xf9, 0x8f, 0xb1, 0x1b, 0x59, 0xcc, 0x93, 0x6c, 0x74, 0x97, 0xeb, 0xec, 0xa1, 0xc4, 0x9c, 0x1c,
	0x27, 0x31, 0xa7, 0xc6, 0x4f, 0xcc, 0xe9, 0x73, 0x12, 0xf3, 0x2b, 0xf7, 0xc9, 0x8f, 0x93, 0x70,
	0xf5, 0xa0, 0xa7, 0xa9, 0x2e, 0xfe, 0x25, 0x31, 0xb5, 0xec, 0x53, 0xe3, 0x99, 0x3a, 0x79, 0x91,
	0xbc, 0xcf, 0x69, 0xf2, 0xc4, 0x7e, 0x5e, 0x79, 0x90, 0x7a, 0xe5, 0xe5, 0x41, 0xfa, 0x32, 0x7d,
	0xf5, 0x73, 0x01, 0x16, 0x36, 0x75, 0x53, 0xdb, 0xd1, 0x1d, 0x47, 0x37, 0x3b, 0x6b, 0x86, 0x75,
	0xe8, 0x4c, 0xe4, 0xa9, 0x07, 0x50, 0x3c, 0x34, 0xac, 0x43, 0xee, 0x27, 0xaf, 0x45, 0x32, 0xb6,
	0xa3, 0x0a, 0x04, 0x99, 0xfd, 0x8e, 0x0d, 0xcc, 0xe4, 0x65, 0x2a, 0xdb, 0x87, 0xf2, 0xb0, 0xae,
	0xbc, 0x28, 0x78, 0x02, 0xb3, 0x5d, 0x06, 0x57, 0x5e, 0x46, 0x1f, 0xd4, 0x0d, 0x88, 0x73, 0xb5,
	0xa4, 0x3f, 0x4e, 0xc2, 0xc2, 0x9a, 0xea, 0xb6, 0x8f, 0xd9, 0xa2, 0x98, 0xdc, 0xc6, 0xdf, 0x81,
	0x9c, 0xcd, 0xe6, 0x7b, 0xf2, 0x8c, 0xae, 0x0a, 0xce, 0x61, 0x58, 0xe5, 0x7f, 0x65, 0x9f, 0xe2,
	0xab, 0x0e, 0xb1, 0xca, 0x9f, 0x08, 0x90, 0xf5, 0xd4, 0x7d, 0xe9, 0xb2, 0x0f, 0x41, 0x8a, 0x6e,
	0x58, 0x09, 0x76, 0xeb, 0x4f, 0xf7, 0x98, 0x6f, 0x01, 0xb4, 0xad, 0x6e, 0xcf, 0xc6, 0x8e, 0x63,
	0xd9, 0x3c, 0x62, 0xee, 0x8c, 0x73, 0x9b, 0xcb, 0x51, 0xb8, 0xdc, 0x21, 0x22, 0xd2, 0xff, 0x08,
	0x50, 0x1e, 0xb6, 0x20, 0x0f, 0x95, 0xef, 0x41, 0xde, 0xe6, 0xbf, 0xbd, 0xdb, 0xb0, 0xb5, 0x0b,
	0xf8, 0x83, 0x97, 0x6b, 0xde, 0x0f, 0x39, 0x20, 0x5a, 0x79, 0x06, 0x39, 0x9f, 0xdb, 0x4b, 0x9b,
	0x2c, 0x28, 0x41, 0x13, 0xa3, 0x4a, 0x50, 0xe9, 0x6f, 0x13, 0x30, 0x47, 0x25, 0x25, 0x05, 0xf4,
	0xe4, 0x81, 0xba, 0x0a, 0xd9, 0x0b, 0xae, 0x1b, 0x0f, 0x0f, 0x1d, 0xc3, 0xbc, 0xda, 0x6e, 0xe3,
	0x1e, 0x6d, 0xd9, 0x28, 0x81, 0x4b, 0x58, 0x9f, 0xf1, 0x42, 0x8e, 0x9d, 0x0b, 0x08, 0x06, 0x63,
	0xb1, 0x71, 0x9f, 0xba, 0xcc, 0x6c, 0xf3, 0x4f, 0x09, 0x98, 0x1f, 0xb4, 0x25, 0xf7, 0xe9, 0x67,
	0xc3, 0x11, 0x34, 0xe6, 0x8a, 0x1e, 0xa2, 0x15, 0x1b, 0x3f, 0xff, 0x22, 0x5c, 0x66, 0x00, 0x8d,
	0x5e, 0x73, 0xa9, 0x4b, 0x58, 0x73, 0x93, 0x1c, 0x95, 0xa4, 0x1f, 0x25, 0x60, 0xfa, 0x63, 0xec,
	0xb6, 0x6c, 0x3c, 0x59, 0xaf, 0xe2, 0x3e, 0x14, 0x5e, 0xe2, 0x69, 0x13, 0xd8, 0xc1, 0xab, 0xa6,
	0x6b, 0x90, 0xef, 0xa9, 0x1d, 0xac, 0x38, 0xfa, 0x17, 0xac, 0x44, 0x4f, 0xcb, 0x39, 0x02, 0x68,
	0xea, 0x5f, 0xd0, 0xd6, 0x31, 0x1d, 0x74, 0xad, 0xa7, 0xd8, 0xe4, 0x25, 0x39, 0x9d, 0xde, 0x22,
	0x80, 0x57, 0xbe, 0xa9, 0x7f, 0x5f, 0x80, 0x92, 0x6f, 0x1d, 0x1e, 0x05, 0xdb, 0xd1, 0xc7, 0x10,
	0xc2, 0xc4, 0x4d, 0xc3, 0xc8, 0x43, 0x88, 0xaf, 0x40, 0xc9, 0xc4, 0xa7, 0xae, 0x12, 0xd2, 0x92,
	0x75, 0xc3, 0xa6, 0x08, 0x78, 0xdf, 0xd3, 0x54, 0xfa, 0x37, 0x01, 0xc4, 0x66, 0xcf, 0xd0, 0x5d,
	0x12, 0xb3, 0x93, 0x7a, 0x2a, 0xb4, 0x0f, 0x4f, 0xec, 0xa9, 0xa0, 0xac, 0x78, 0xe5, 0x55, 0x85,
	0x0a, 0x33, 0x21, 0x15, 0x7d, 0x73, 0x4f, 0xb5, 0x8f, 0xfb, 0xe6, 0x53, 0xbf, 0x8e, 0x10, 0x26,
	0xcb, 0x87, 0x45, 0x8a, 0xed, 0x57, 0x10, 0x09, 0xc6, 0xa3, 0x8d, 0x7f, 0x81, 0x76, 0x1c, 0x52,
	0x29, 0xf9, 0x12, 0x2a, 0xbd, 0xf2, 0xec, 0xfb, 0x19, 0xa0, 0xb0, 0xc5, 0xb8, 0x5b, 0x06, 0xac,
	0x21, 0x5c, 0xd8, 0x1a, 0xd2, 0x37, 0xe9, 0x59, 0x72, 0x5d, 0xed, 0xa9, 0x87, 0xba, 0xa1, 0xd3,
	0xbe, 0xed, 0x04, 0x6e, 0x91, 0xfe, 0x26, 0x09, 0x88, 0xf5, 0x5b, 0xc2, 0x24, 0x90, 0x0a, 0x88,
	0x9d, 0x26, 0xda, 0x21, 0x28, 0x17, 0x73, 0xf4, 0x9b, 0x2c, 0x7a, 0x70, 0x88, 0x88, 0x34, 0xd3,
	0x1e, 0x04, 0xa1, 0x2e, 0xcc, 0x87, 0x2e, 0xaa, 0xc3, 0x6c, 0x58, 0x6c, 0x7c, 0x30, 0x7e, 0x43,
	0x24, 0xc2, 0x6a, 0x0e, 0xc7, 0x81, 0xd1, 0x3e, 0xcc, 0x6b, 0xb8, 0x67, 0xe3, 0xb6, 0xea, 0x62,
	0x4d, 0x51, 0x7b, 0xba, 0x72, 0x82, 0x6d, 0xc7, 0x5b, 0x84, 0x85, 0x7a, 0x25, 0xc2, 0x8e, 0x3f,
	0xe0, 0x6d, 0xe2, 0xee, 0x43, 0x6c, 0xcb, 0xb3, 0x01, 0xe6, 0x6a, 0x4f, 0x7f, 0xc8, 0xf0, 0xd0,
	0x1a, 0x94, 0x0c, 0xeb, 0x59, 0x84, 0x54, 0x6a, 0x24, 0xa9, 0x29, 0xc3, 0x7a, 0x16, 0xa2, 0xb1,
	0x01, 0xe2, 0xb1, 0xde, 0x39, 0x8e, 0x10, 0x49, 0x8f, 0x24, 0x32, 0x4d, 0x70, 0x02, 0x2a, 0xd2,
	0xef, 0x0b, 0x30, 0x1d, 0x0d, 0x46, 0xe9, 0x07, 0x42, 0x6c, 0x33, 0x0b, 0x20, 0xd3, 0xbc, 0xbf,
	0x5a, 0xbf, 0xfb, 0x81, 0x28, 0xa0, 0x1c, 0xa4, 0x9a, 0xf7, 0x57, 0xef, 0x88, 0x09, 0x94, 0x85,
	0xe4, 0xce, 0xc6, 0x5d, 0x31, 0x49, 0x7e, 0x3c, 0x6c, 0xee, 0x89, 0x29, 0x3e, 0x6f, 0xf9, 0xde,
	0xfb, 0x62, 0x9a, 0xff, 0xbe, 0x7b, 0xa7, 0x2e, 0x66, 0x08, 0xb1, 0x9d, 0x03, 0x79, 0xe7, 0x40,
	0x5e, 0x16, 0xb3, 0x68, 0x1a, 0x80, 0x11, 0x6b, 0xc9, 0x8d, 0x86, 0x98, 0x23, 0x13, 0xd7, 0xb6,
	0x57, 0x3f, 0x69, 0x2c, 0x8b, 0x79, 0x32, 0xf1, 0xe3, 0xad, 0x16, 0xa5, 0x0f, 0xd2, 0x26, 0x5c,
	0x67, 0x27, 0x58, 0x1a, 0x18, 0xac, 0xf8, 0x8c, 0x38, 0xe7, 0x2d, 0x98, 0xee, 0x53, 0xa8, 0x82,
	0x4d, 0x52, 0x1e, 0x69, 0x34, 0xd4, 0x72, 0xf2, 0x14, 0x83, 0x36, 0x18, 0x50, 0xfa, 0xa9, 0x00,
	0xb3, 0xfb, 0xfc, 0x9a, 0x20, 0x82, 0xdf, 0x06, 0xe0, 0xd7, 0x07, 0xc1, 0x9e, 0xb2, 0x3e, 0xfa,
	0xe9, 0x60, 0x0c, 0x29, 0x1f, 0x28, 0xab, 0x66, 0x07, 0xcb, 0x21, 0xb2, 0x95, 0x03, 0x98, 0x8a,
	0x0c, 0xa2, 0x5b, 0x50, 0xec, 0xea, 0xa6, 0x32, 0x70, 0x91, 0x51, 0xe8, 0xea, 0xa6, 0x37, 0x8f,
	0x4e, 0x51, 0x4f, 0x83, 0x29, 0x09, 0x3e, 0x45, 0x3d, 0xf5, 0xa6, 0x48, 0xfb, 0x70, 0x8d, 0x5f,
	0xf3, 0xac, 0x1e, 0x3a, 0x96, 0xd1, 0x77, 0xf1, 0xbe, 0xea, 0x1e, 0x37, 0x5d, 0x5b, 0x75, 0x71,
	0xe7, 0x4c, 0xba, 0x13, 0xeb, 0xc7, 0x69, 0x80, 0x8d, 0xad, 0xe6, 0xea, 0xf6, 0xf6, 0xde, 0xa3,
	0xc6, 0x86, 0x28, 0x90, 0x41, 0xef, 0x23, 0x21, 0x6d, 0x02, 0x04, 0x05, 0x8e, 0x74, 0xcf, 0x23,
	0x50, 0x84, 0xdc, 0xd6, 0x46, 0x63, 0xb7, 0xb5, 0xd5, 0x7a, 0x22, 0xbe, 0x46, 0xbc, 0xff, 0x69,
	0xb3, 0xc5, 0x71, 0x37, 0x1a, 0x9b, 0xdb, 0xab, 0xad, 0x86, 0x98, 0xa0, 0x3e, 0x94, 0xf7, 0x5a,
	0xdb, 0x5b, 0x62, 0x52, 0xfa, 0xf3, 0x2c, 0xcc, 0x0c, 0x2d, 0x65, 0xf4, 0x3d, 0x10, 0x07, 0x12,
	0x26, 0xb3, 0xf8, 0x85, 0x33, 0x66, 0x29, 0x9a, 0x31, 0x1d, 0xf4, 0x7d, 0x01, 0x6e, 0xf2, 0x3e,
	0x09, 0x4b, 0x42, 0x3c, 0x36, 0x62, 0x92, 0xc4, 0x87, 0x63, 0xb6, 0x4e, 0xce, 0x09, 0x3c, 0xf9,
	0xba, 0xfa, 0xc2, 0xb8, 0xec, 0xc3, 0x35, 0xde, 0x54, 0xe1, 0xde, 0x8a, 0xca, 0xc0, 0x32, 0xc7,
	0xdd, 0x0b, 0x05, 0x9a, 0x7c, 0x95, 0x52, 0x8e, 0x0d, 0xe7, 0x15, 0xa8, 0x90, 0xa8, 0x39, 0x24,
	0x85, 0xb6, 0xe2, 0x5a, 0xae, 0x6a, 0x28, 0xa1, 0xe7, 0x62, 0x29, 0xfa, 0x5c, 0x6c, 0xbe, 0xab,
	0x9e, 0xd2, 0x4a, 0xbc, 0x45, 0xc6, 0x9b, 0xde, 0xdb, 0x31, 0x62, 0xbc, 0x37, 0xf8, 0x53, 0x05,
	0x45, 0xe5, 0x01, 0x45, 0xdf, 0x4e, 0x2b, 0x0e, 0x0f, 0x29, 0x5e, 0xe3, 0xad, 0x8d, 0xfb, 0x62,
	0x34, 0x2e, 0x2c, 0xb9, 0xeb, 0xae, 0x39, 0xe7, 0x4f, 0x41, 0x47, 0x30, 0xe7, 0xf4, 0x7b, 0x3d,
	0x7a, 0x6d, 0x1a, 0x39, 0x40, 0x65, 0x2e, 0x7a, 0x80, 0x9a, 0xf5, 0xe9, 0x85, 0xcf, 0x4f, 0xbf,
	0x06, 0x52, 0xc0, 0x87, 0xd9, 0xcc, 0x0b, 0x98, 0x10, 0xd3, 0xec, 0x45, 0x99, 0xde, 0xf0, 0x89,
	0x87, 0x8e, 0xce, 0x61, 0xfe, 0xef, 0xc3, 0x02, 0xf1, 0x56, 0x5b, 0x75, 0x58, 0xc7, 0x26, 0xe4,
	0xaa, 0x1c, 0x75, 0xd5, 0x95, 0xae, 0x7a, 0xba, 0xae, 0x3a, 0xa4, 0x00, 0x08, 0xfc, 0xf4, 0x2e,
	0x20, 0x87, 0x54, 0x6b, 0x1c, 0x87, 0xf1, 0xa0, 0x57, 0x6e, 0x39, 0x59, 0x74, 0xbc, 0x3a, 0xae,
	0xc9, 0xe0, 0xa8, 0x0a, 0x57, 0x1c, 0x5a, 0x45, 0x44, 0xa7, 0xb3, 0x3b, 0xb4, 0x19, 0xc7, 0x2f,
	0x30, 0xf8, 0x7c, 0xe9, 0xcf, 0x92, 0x30, 0x17, 0xbb, 0x3d, 0xc6, 0xd5, 0x3b, 0xc2, 0x65, 0xde,
	0xf3, 0xdd, 0x82, 0x22, 0x41, 0xf2, 0x13, 0x39, 0xbb, 0x8c, 0x2a, 0x10, 0x18, 0x4f, 0xe3, 0xe8,
	0x39, 0xdc, 0x08, 0x5d, 0x97, 0x5e, 0xfe, 0xca, 0x0a, 0x1e, 0xc0, 0x9d, 0xb3, 0xba, 0xae, 0x06,
	0xf1, 0x32, 0x7c, 0x55, 0x9e, 0x5c, 0xcc, 0xcb, 0x0b, 0xfe, 0x84, 0x81, 0x17, 0xc8, 0x71, 0xc9,
	0x2f, 0x7d, 0x99, 0xc9, 0x4f, 0xda, 0x81, 0x42, 0xcb, 0xb2, 0x8c, 0x0d, 0xec, 0xaa, 0xba, 0x41,
	0x5f, 0x06, 0xb9, 0x96, 0x65, 0x84, 0x0b, 0xb8, 0x1c, 0x01, 0xd0, 0x9a, 0xfa, 0x16, 0x14, 0xe9,
	0xa0, 0x57, 0x39, 0xb0, 0xa3, 0x4f, 0x81, 0xc0, 0xbc, 0xd2, 0xe0, 0x9f, 0x13, 0x50, 0xe2, 0x05,
	0xa1, 0x7f, 0x17, 0xb2, 0xc7, 0xd1, 0x34, 0xc6, 0x83, 0x97, 0x75, 0xa3, 0x5f, 0x90, 0x87, 0xe4,
	0x62, 0x4c, 0x42, 0x42, 0xf2, 0x7c, 0xad, 0x6b, 0x5c, 0x88, 0x1c, 0x03, 0x6c, 0x69, 0x24, 0xd0,
	0x29, 0x37, 0xdd, 0x3c, 0xb1, 0xda, 0xaa, 0x37, 0x8b, 0x5f, 0x26, 0x91, 0x91, 0x2d, 0x7f, 0x60,
	0x4b, 0x23, 0xce, 0x69, 0x5b, 0xb6, 0x8d, 0x0d, 0x5a, 0xa6, 0x05, 0x38, 0x0e, 0x41, 0x62, 0x07,
	0xd8, 0x85, 0x60, 0x42, 0x80, 0xea, 0x6c, 0x69, 0xe8, 0x6d, 0x28, 0x71, 0x31, 0xba, 0x26, 0xee,
	0x5a, 0xa6, 0xde, 0xe6, 0x97, 0x8b, 0xd3, 0x0c, 0xbc, 0xc3, 0xa1, 0xd4, 0xa8, 0xf4, 0xb1, 0x04,
	0x21, 0x9a, 0xe1, 0x46, 0xa5, 0x80, 0x2d, 0x0d, 0x7d, 0x15, 0xc4, 0xb6, 0x65, 0x1e, 0xe9, 0x1d,
	0xfe, 0x30, 0x91, 0xcc, 0xc9, 0xd2, 0x39, 0xa5, 0x08, 0x7c, 0x4b, 0xab, 0xff, 0x45, 0x02, 0xf2,
	0xfe, 0x2a, 0x43, 0x3f, 0x14, 0x20, 0xcb, 0xef, 0xa5, 0x50, 0x6d, 0xfc, 0xdb, 0x52, 0xea, 0x9b,
	0xca, 0x75, 0xaf, 0xc9, 0x10, 0xfa, 0x3f, 0xb0, 0xaa, 0x7f, 0x69, 0x28, 0xdd, 0xf9, 0xf5, 0x9f,
	0xfd, 0xfb, 0x6f, 0x25, 0xde, 0x59, 0x11, 0x96, 0xa4, 0xaf, 0xd4, 0x4e, 0xea, 0xb5, 0x2f, 0x23,
	0x95, 0xfd, 0x37, 0x97, 0x96, 0x9e, 0xd7, 0x98, 0x8e, 0xce, 0x0a, 0xe3, 0x82, 0x6f, 0x0b, 0xe8,
	0xf7, 0x04, 0x98, 0x8a, 0x5c, 0x4a, 0xa1, 0xd1, 0x41, 0x1a, 0x77, 0x89, 0x35, 0xb1, 0x70, 0x54,
	0xa6, 0xe0, 0x9f, 0xd8, 0x6a, 0x4b, 0x4b, 0xcf, 0x57, 0x9e, 0x85, 0x09, 0xdf, 0x16, 0xea, 0xff,
	0x90, 0x84, 0x42, 0x68, 0x6f, 0x46, 0xff, 0xc8, 0x7a, 0x05, 0x91, 0x67, 0x8f, 0xa3, 0xef, 0x01,
	0xe3, 0xaf, 0xd1, 0x2a, 0x93, 0xdd, 0xa8, 0x48, 0xdf, 0xa1, 0x0a, 0x3c, 0x44, 0xad, 0x17, 0x9a,
	0x96, 0xdf, 0x94, 0xd4, 0xbe, 0x8c, 0xdc, 0x08, 0x55, 0x8f, 0x55, 0xe7, 0xf8, 0xf9, 0x20, 0x30,
	0xd8, 0x03, 0x9e, 0xa3, 0xff, 0x16, 0x00, 0x0d, 0x5f, 0x43, 0xa1, 0x95, 0x91, 0x32, 0x9e, 0x7b,
	0x77, 0x35, 0xa9, 0x7e, 0x4f, 0xa9, 0x7e, 0x78, 0x25, 0x7a, 0xfb, 0x54, 0x79, 0x25, 0xea, 0xd6,
	0x7f, 0x27, 0x0f, 0x57, 0xd7, 0xd9, 0x73, 0xb6, 0x55, 0x4d, 0x23, 0x9b, 0x24, 0xc9, 0xfa, 0x4d,
	0xd7, 0xb2, 0xd5, 0x0e, 0x46, 0x7f, 0x29, 0x80, 0x38, 0x78, 0xf7, 0x81, 0xee, 0x8d, 0xf1, 0x2f,
	0x35, 0xb1, 0x57, 0x43, 0x95, 0xaf, 0x5f, 0x00, 0x93, 0x1d, 0xc1, 0xa5, 0x65, 0x6a, 0x94, 0xf7,
	0x48, 0xd4, 0x2e, 0x9e, 0x63, 0x08, 0xb2, 0xd7, 0x3a, 0x2b, 0x47, 0x01, 0x05, 0x2a, 0xfe, 0x60,
	0x07, 0x7d, 0x0c, 0xf1, 0xcf, 0xb9, 0x04, 0x19, 0x43, 0xfc, 0xf3, 0xda, 0xf5, 0xe3, 0x8b, 0x7f,
	0x18, 0x50, 0x40, 0x7f, 0x2a, 0xc0, 0x74, 0xb4, 0x7d, 0x8b, 0x3e, 0x98, 0xb8, 0xdf, 0xcb, 0x44,
	0xff, 0xda, 0x05, 0xfb, 0xc4, 0xe3, 0xa4, 0xb2, 0x90, 0xe0, 0x04, 0x1f, 0xfd, 0x44, 0x80, 0x2c,
	0xef, 0x23, 0x8e, 0x91, 0x59, 0xa3, 0xfd, 0xd8, 0xca, 0xed, 0xf1, 0x11, 0xb8, 0x84, 0x8f, 0xa9,
	0x84, 0x32, 0xda, 0x7f, 0x91, 0x78, 0xb5, 0x2f, 0x43, 0x0d, 0x5c, 0x6f, 0x55, 0x84, 0x41, 0xa1,
	0x35, 0xb1, 0xd2, 0x61, 0x1c, 0x6e, 0x0b, 0xe8, 0xef, 0x05, 0xc8, 0xfb, 0x5d, 0x3a, 0x34, 0xba,
	0x1c, 0x1d, 0x6c, 0x5a, 0x56, 0xea, 0x93, 0xa0, 0x70, 0x85, 0x3e, 0xa5, 0x0a, 0xb5, 0x90, 0xfc,
	0x62, 0x85, 0x42, 0x1d, 0x29, 0x4f, 0xa1, 0x30, 0x28, 0xac, 0x90, 0x5f, 0xa0, 0xa2, 0x1f, 0x0b,
	0x00, 0x41, 0x83, 0x0b, 0x8d, 0x27, 0x5e, 0xa4, 0x7f, 0x58, 0x59, 0x9e, 0x08, 0x87, 0xeb, 0x54,
	0xa7, 0x3a, 0xbd, 0x4b, 0xc2, 0xe8, 0xed, 0x17, 0x86, 0x51, 0x50, 0x1c, 0xd7, 0xff, 0x4a, 0x80,
	0x62, 0xa4, 0x14, 0xfc, 0x23, 0xb6, 0xe9, 0x44, 0x60, 0x63, 0x6d, 0x3a, 0x31, 0xfd, 0xb6, 0x71,
	0xd4, 0x18, 0x6a, 0xb4, 0x49, 0xef, 0x50, 0x35, 0xde, 0x42, 0x6f, 0x9e, 0xa3, 0x43, 0xb8, 0x2a,
	0x5e, 0xfb, 0x6b, 0x01, 0x46, 0xfd, 0x4b, 0xfa, 0xda, 0xac, 0x4c, 0x81, 0xc1, 0xb3, 0x42, 0xdb,
	0x72, 0xad, 0x7d, 0xe1, 0xd3, 0xef, 0x76, 0x74, 0xf7, 0xb8, 0x7f, 0x58, 0x6d, 0x5b, 0xdd, 0x5a,
	0x5b, 0xb7, 0xed, 0xbe, 0x63, 0xa8, 0x87, 0x4e, 0xcd, 0xea, 0x9a, 0xfa, 0x7b, 0xf4, 0x24, 0x5a,
	0xd3, 0x4d, 0x17, 0xdb, 0xa6, 0x6a, 0xd4, 0xc6, 0xf8, 0x8f, 0xf9, 0x6f, 0x30, 0x98, 0x0f, 0xfa,
	0x83, 0x44, 0x52, 0x6e, 0x3c, 0xfe, 0xc3, 0xc4, 0x8d, 0x35, 0x2a, 0xde, 0x1a, 0x15, 0x8f, 0x49,
	0x12, 0xb4, 0xe9, 0xaa, 0x0f, 0xeb, 0x87, 0x19, 0xfa, 0xbf, 0x0f, 0xcb, 0xff, 0x17, 0x00, 0x00,
	0xff, 0xff, 0x94, 0x91, 0x02, 0x50, 0x97, 0x3f, 0x00, 0x00,
}
